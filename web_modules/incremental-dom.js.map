{"version":3,"file":"incremental-dom.js","sources":["../node_modules/incremental-dom/dist/incremental-dom-cjs.js"],"sourcesContent":["\n/**\n * @preserve\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The name of the HTML attribute that holds the element key\n * (e.g. `<div key=\"foo\">`). The attribute value, if it exists, is then used\n * as the default key when importing an element.\n * If null, no attribute value is used as the default key.\n */\nlet keyAttributeName = \"key\";\nfunction getKeyAttributeName() {\n    return keyAttributeName;\n}\nfunction setKeyAttributeName(name) {\n    keyAttributeName = name;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Keeps track whether or not we are in an attributes declaration (after\n * elementOpenStart, but before elementOpenEnd).\n */\nlet inAttributes = false;\n/**\n * Keeps track whether or not we are in an element that should not have its\n * children cleared.\n */\nlet inSkip = false;\n/**\n * Keeps track of whether or not we are in a patch.\n */\nlet inPatch = false;\n/**\n * Asserts that a value exists and is not null or undefined. goog.asserts\n * is not used in order to avoid dependencies on external code.\n * @param val The value to assert is truthy.\n * @returns The value.\n */\nfunction assert(val) {\n    if (!val) {\n        throw new Error(\"Expected value to be defined\");\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return val;\n}\n/**\n * Makes sure that there is a current patch context.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertInPatch(functionName) {\n    if (!inPatch) {\n        throw new Error(\"Cannot call \" + functionName + \"() unless in patch.\");\n    }\n}\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param openElement\n * @param root\n */\nfunction assertNoUnclosedTags(openElement, root) {\n    if (openElement === root) {\n        return;\n    }\n    let currentElement = openElement;\n    const openTags = [];\n    while (currentElement && currentElement !== root) {\n        openTags.push(currentElement.nodeName.toLowerCase());\n        currentElement = currentElement.parentNode;\n    }\n    throw new Error(\"One or more tags were not closed:\\n\" + openTags.join(\"\\n\"));\n}\n/**\n * Makes sure that node being outer patched has a parent node.\n * @param parent\n */\nfunction assertPatchOuterHasParentNode(parent) {\n    if (!parent) {\n        console.warn(\"patchOuter requires the node have a parent if there is a key.\");\n    }\n}\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertNotInAttributes(functionName) {\n    if (inAttributes) {\n        throw new Error(functionName +\n            \"() can not be called between \" +\n            \"elementOpenStart() and elementOpenEnd().\");\n    }\n}\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertNotInSkip(functionName) {\n    if (inSkip) {\n        throw new Error(functionName +\n            \"() may not be called inside an element \" +\n            \"that has called skip().\");\n    }\n}\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertInAttributes(functionName) {\n    if (!inAttributes) {\n        throw new Error(functionName +\n            \"() can only be called after calling \" +\n            \"elementOpenStart().\");\n    }\n}\n/**\n * Makes sure the patch closes virtual attributes call\n */\nfunction assertVirtualAttributesClosed() {\n    if (inAttributes) {\n        throw new Error(\"elementOpenEnd() must be called after calling \" + \"elementOpenStart().\");\n    }\n}\n/**\n * Makes sure that tags are correctly nested.\n * @param currentNameOrCtor\n * @param nameOrCtor\n */\nfunction assertCloseMatchesOpenTag(currentNameOrCtor, nameOrCtor) {\n    if (currentNameOrCtor !== nameOrCtor) {\n        throw new Error('Received a call to close \"' +\n            nameOrCtor +\n            '\" but \"' +\n            currentNameOrCtor +\n            '\" was open.');\n    }\n}\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param functionName The name of the caller, for the error message.\n * @param previousNode\n */\nfunction assertNoChildrenDeclaredYet(functionName, previousNode) {\n    if (previousNode !== null) {\n        throw new Error(functionName +\n            \"() must come before any child \" +\n            \"declarations inside the current element.\");\n    }\n}\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param maybeStartNode The value for the currentNode when the patch\n *     started.\n * @param maybeCurrentNode The currentNode when the patch finished.\n * @param expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nfunction assertPatchElementNoExtras(maybeStartNode, maybeCurrentNode, expectedNextNode, expectedPrevNode) {\n    const startNode = assert(maybeStartNode);\n    const currentNode = assert(maybeCurrentNode);\n    const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n        currentNode.previousSibling === expectedPrevNode;\n    const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n        currentNode.previousSibling === expectedPrevNode;\n    const wasRemoved = currentNode === startNode;\n    if (!wasUpdated && !wasChanged && !wasRemoved) {\n        throw new Error(\"There must be exactly one top level call corresponding \" +\n            \"to the patched element.\");\n    }\n}\n/**\n * @param newContext The current patch context.\n */\nfunction updatePatchContext(newContext) {\n    inPatch = newContext != null;\n}\n/**\n * Updates the state of being in an attribute declaration.\n * @param value Whether or not the patch is in an attribute declaration.\n * @return the previous value.\n */\nfunction setInAttributes(value) {\n    const previous = inAttributes;\n    inAttributes = value;\n    return previous;\n}\n/**\n * Updates the state of being in a skip element.\n * @param value Whether or not the patch is skipping the children of a\n *    parent node.\n * @return the previous value.\n */\nfunction setInSkip(value) {\n    const previous = inSkip;\n    inSkip = value;\n    return previous;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * A constructor function that will create blank objects.\n */\nfunction Blank() { }\nBlank.prototype = Object.create(null);\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param map The map to check.\n * @param property The property to check.\n * @return Whether map has property.\n */\nfunction has(map, property) {\n    return hasOwnProperty.call(map, property);\n}\n/**\n * Creates an map object without a prototype.\n * @returns An Object that can be used as a map.\n */\nfunction createMap() {\n    return new Blank();\n}\n/**\n * Truncates an array, removing items up until length.\n * @param arr The array to truncate.\n * @param length The new length of the array.\n */\nfunction truncateArray(arr, length) {\n    while (arr.length > length) {\n        arr.pop();\n    }\n}\n/**\n * Creates an array for a desired initial size. Note that the array will still\n * be empty.\n * @param initialAllocationSize The initial size to allocate.\n * @returns An empty array, with an initial allocation for the desired size.\n */\nfunction createArray(initialAllocationSize) {\n    const arr = new Array(initialAllocationSize);\n    truncateArray(arr, 0);\n    return arr;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst symbols = {\n    default: \"__default\"\n};\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param name The name of the attribute. For example \"tabindex\" or\n *    \"xlink:href\".\n * @returns The namespace to use for the attribute, or null if there is\n * no namespace.\n */\nfunction getNamespace(name) {\n    if (name.lastIndexOf(\"xml:\", 0) === 0) {\n        return \"http://www.w3.org/XML/1998/namespace\";\n    }\n    if (name.lastIndexOf(\"xlink:\", 0) === 0) {\n        return \"http://www.w3.org/1999/xlink\";\n    }\n    return null;\n}\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param el The element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value.\n */\nfunction applyAttr(el, name, value) {\n    if (value == null) {\n        el.removeAttribute(name);\n    }\n    else {\n        const attrNS = getNamespace(name);\n        if (attrNS) {\n            el.setAttributeNS(attrNS, name, String(value));\n        }\n        else {\n            el.setAttribute(name, String(value));\n        }\n    }\n}\n/**\n * Applies a property to a given Element.\n * @param el The element to apply the property to.\n * @param name The property's name.\n * @param value The property's value.\n */\nfunction applyProp(el, name, value) {\n    el[name] = value;\n}\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param style A style declaration.\n * @param prop The property to apply. This can be either camelcase or dash\n *    separated. For example: \"backgroundColor\" and \"background-color\" are both\n *    supported.\n * @param value The value of the property.\n */\nfunction setStyleValue(style, prop, value) {\n    if (prop.indexOf(\"-\") >= 0) {\n        style.setProperty(prop, value);\n    }\n    else {\n        style[prop] = value;\n    }\n}\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param el The Element to apply the style for.\n * @param name The attribute's name.\n * @param  style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nfunction applyStyle(el, name, style) {\n    // MathML elements inherit from Element, which does not have style. We cannot\n    // do `instanceof HTMLElement` / `instanceof SVGElement`, since el can belong\n    // to a different document, so just check that it has a style.\n    assert(\"style\" in el);\n    const elStyle = el.style;\n    if (typeof style === \"string\") {\n        elStyle.cssText = style;\n    }\n    else {\n        elStyle.cssText = \"\";\n        for (const prop in style) {\n            if (has(style, prop)) {\n                setStyleValue(elStyle, prop, style[prop]);\n            }\n        }\n    }\n}\n/**\n * Updates a single attribute on an Element.\n * @param el The Element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction applyAttributeTyped(el, name, value) {\n    const type = typeof value;\n    if (type === \"object\" || type === \"function\") {\n        applyProp(el, name, value);\n    }\n    else {\n        applyAttr(el, name, value);\n    }\n}\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * NB: The result of createMap() has to be recast since closure compiler\n * will just assume attributes is \"any\" otherwise and throws away\n * the type annotation set by tsickle.\n */\nconst attributes = createMap();\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\nattributes[\"style\"] = applyStyle;\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param el The Element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction updateAttribute(el, name, value) {\n    const mutator = attributes[name] || attributes[symbols.default];\n    mutator(el, name, value);\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst notifications = {\n    nodesCreated: null,\n    nodesDeleted: null\n};\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A context object keeps track of the state of a patch.\n */\nclass Context {\n    constructor() {\n        this.created = [];\n        this.deleted = [];\n    }\n    markCreated(node) {\n        this.created.push(node);\n    }\n    markDeleted(node) {\n        this.deleted.push(node);\n    }\n    /**\n     * Notifies about nodes that were created during the patch operation.\n     */\n    notifyChanges() {\n        if (notifications.nodesCreated && this.created.length > 0) {\n            notifications.nodesCreated(this.created);\n        }\n        if (notifications.nodesDeleted && this.deleted.length > 0) {\n            notifications.nodesDeleted(this.deleted);\n        }\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Checks if the node is the root of a document. This is either a Document\n * or ShadowRoot. DocumentFragments are included for simplicity of the\n * implementation, though we only want to consider Documents or ShadowRoots.\n * @param node The node to check.\n * @return True if the node the root of a document, false otherwise.\n */\nfunction isDocumentRoot(node) {\n    return node.nodeType === 11 || node.nodeType === 9;\n}\n/**\n * Checks if the node is an Element. This is faster than an instanceof check.\n * @param node The node to check.\n * @return Whether or not the node is an Element.\n */\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\n/**\n * @param  node The node to start at, inclusive.\n * @param  root The root ancestor to get until, exclusive.\n * @return The ancestry of DOM nodes.\n */\nfunction getAncestry(node, root) {\n    const ancestry = [];\n    let cur = node;\n    while (cur !== root) {\n        const n = assert(cur);\n        ancestry.push(n);\n        cur = n.parentNode;\n    }\n    return ancestry;\n}\n/**\n * @param this\n * @returns The root node of the DOM tree that contains this node.\n */\nconst getRootNode = (typeof Node !== \"undefined\" && Node.prototype.getRootNode) ||\n    function () {\n        let cur = this;\n        let prev = cur;\n        while (cur) {\n            prev = cur;\n            cur = cur.parentNode;\n        }\n        return prev;\n    };\n/**\n * @param node The node to get the activeElement for.\n * @returns The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nfunction getActiveElement(node) {\n    const root = getRootNode.call(node);\n    return isDocumentRoot(root) ? root.activeElement : null;\n}\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param node The reference node to get the activeElement for.\n * @param root The root to get the focused path until.\n * @returns The path of focused parents, if any exist.\n */\nfunction getFocusedPath(node, root) {\n    const activeElement = getActiveElement(node);\n    if (!activeElement || !node.contains(activeElement)) {\n        return [];\n    }\n    return getAncestry(activeElement, root);\n}\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param parentNode\n * @param node\n * @param referenceNode\n */\nfunction moveBefore(parentNode, node, referenceNode) {\n    const insertReferenceNode = node.nextSibling;\n    let cur = referenceNode;\n    while (cur !== null && cur !== node) {\n        const next = cur.nextSibling;\n        parentNode.insertBefore(cur, insertReferenceNode);\n        cur = next;\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n */\nclass NodeData {\n    constructor(nameOrCtor, key, text) {\n        /**\n         * An array of attribute name/value pairs, used for quickly diffing the\n         * incomming attributes to see if the DOM node's attributes need to be\n         * updated.\n         */\n        this._attrsArr = null;\n        /**\n         * Whether or not the statics have been applied for the node yet.\n         */\n        this.staticsApplied = false;\n        this.nameOrCtor = nameOrCtor;\n        this.key = key;\n        this.text = text;\n    }\n    hasEmptyAttrsArr() {\n        const attrs = this._attrsArr;\n        return !attrs || !attrs.length;\n    }\n    getAttrsArr(length) {\n        return this._attrsArr || (this._attrsArr = createArray(length));\n    }\n}\n/**\n * Initializes a NodeData object for a Node.\n * @param node The Node to initialized data for.\n * @param nameOrCtor The NameOrCtorDef to use when diffing.\n * @param key The Key for the Node.\n * @param text The data of a Text node, if importing a Text node.\n * @returns A NodeData object with the existing attributes initialized.\n */\nfunction initData(node, nameOrCtor, key, text) {\n    const data = new NodeData(nameOrCtor, key, text);\n    node[\"__incrementalDOMData\"] = data;\n    return data;\n}\n/**\n * @param node The node to check.\n * @returns True if the NodeData already exists, false otherwise.\n */\nfunction isDataInitialized(node) {\n    return Boolean(node[\"__incrementalDOMData\"]);\n}\n/**\n * Records the element's attributes.\n * @param node The Element that may have attributes\n * @param data The Element's data\n */\nfunction recordAttributes(node, data) {\n    const attributes = node.attributes;\n    const length = attributes.length;\n    if (!length) {\n        return;\n    }\n    const attrsArr = data.getAttrsArr(length);\n    // Use a cached length. The attributes array is really a live NamedNodeMap,\n    // which exists as a DOM \"Host Object\" (probably as C++ code). This makes the\n    // usual constant length iteration very difficult to optimize in JITs.\n    for (let i = 0, j = 0; i < length; i += 1, j += 2) {\n        const attr = attributes[i];\n        const name = attr.name;\n        const value = attr.value;\n        attrsArr[j] = name;\n        attrsArr[j + 1] = value;\n    }\n}\n/**\n * Imports single node and its subtree, initializing caches, if it has not\n * already been imported.\n * @param node The node to import.\n * @param fallbackKey A key to use if importing and no key was specified.\n *    Useful when not transmitting keys from serverside render and doing an\n *    immediate no-op diff.\n * @returns The NodeData for the node.\n */\nfunction importSingleNode(node, fallbackKey) {\n    if (node[\"__incrementalDOMData\"]) {\n        return node[\"__incrementalDOMData\"];\n    }\n    const nodeName = isElement(node) ? node.localName : node.nodeName;\n    const keyAttrName = getKeyAttributeName();\n    const keyAttr = isElement(node) && keyAttrName != null\n        ? node.getAttribute(keyAttrName)\n        : null;\n    const key = isElement(node) ? keyAttr || fallbackKey : null;\n    const data = initData(node, nodeName, key);\n    if (isElement(node)) {\n        recordAttributes(node, data);\n    }\n    return data;\n}\n/**\n * Imports node and its subtree, initializing caches.\n * @param node The Node to import.\n */\nfunction importNode(node) {\n    importSingleNode(node);\n    for (let child = node.firstChild; child; child = child.nextSibling) {\n        importNode(child);\n    }\n}\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n * @param node The node to get data for.\n * @param fallbackKey A key to use if importing and no key was specified.\n *    Useful when not transmitting keys from serverside render and doing an\n *    immediate no-op diff.\n * @returns The NodeData for the node.\n */\nfunction getData(node, fallbackKey) {\n    return importSingleNode(node, fallbackKey);\n}\n/**\n * Gets the key for a Node. note that the Node should have been imported\n * by now.\n * @param node The node to check.\n * @returns The key used to create the node.\n */\nfunction getKey(node) {\n    assert(node[\"__incrementalDOMData\"]);\n    return getData(node).key;\n}\n/**\n * Clears all caches from a node and all of its children.\n * @param node The Node to clear the cache for.\n */\nfunction clearCache(node) {\n    node[\"__incrementalDOMData\"] = null;\n    for (let child = node.firstChild; child; child = child.nextSibling) {\n        clearCache(child);\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param tag The tag to get the namespace for.\n * @param parent The current parent Node, if any.\n * @returns The namespace to use,\n */\nfunction getNamespaceForTag(tag, parent) {\n    if (tag === \"svg\") {\n        return \"http://www.w3.org/2000/svg\";\n    }\n    if (tag === \"math\") {\n        return \"http://www.w3.org/1998/Math/MathML\";\n    }\n    if (parent == null) {\n        return null;\n    }\n    if (getData(parent).nameOrCtor === \"foreignObject\") {\n        return null;\n    }\n    return parent.namespaceURI;\n}\n/**\n * Creates an Element and initializes the NodeData.\n * @param doc The document with which to create the Element.\n * @param parent The parent of new Element.\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key A key to identify the Element.\n * @returns The newly created Element.\n */\nfunction createElement(doc, parent, nameOrCtor, key) {\n    let el;\n    if (typeof nameOrCtor === \"function\") {\n        el = new nameOrCtor();\n    }\n    else {\n        const namespace = getNamespaceForTag(nameOrCtor, parent);\n        if (namespace) {\n            el = doc.createElementNS(namespace, nameOrCtor);\n        }\n        else {\n            el = doc.createElement(nameOrCtor);\n        }\n    }\n    initData(el, nameOrCtor, key);\n    return el;\n}\n/**\n * Creates a Text Node.\n * @param doc The document with which to create the Element.\n * @returns The newly created Text.\n */\nfunction createText(doc) {\n    const node = doc.createTextNode(\"\");\n    initData(node, \"#text\", null);\n    return node;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default match function to use, if one was not specified when creating\n * the patcher.\n * @param matchNode The node to match against, unused.\n * @param nameOrCtor The name or constructor as declared.\n * @param expectedNameOrCtor The name or constructor of the existing node.\n * @param key The key as declared.\n * @param expectedKey The key of the existing node.\n * @returns True if the node matches, false otherwise.\n */\nfunction defaultMatchFn(matchNode, nameOrCtor, expectedNameOrCtor, key, expectedKey) {\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return nameOrCtor == expectedNameOrCtor && key == expectedKey;\n}\nlet context = null;\nlet currentNode = null;\nlet currentParent = null;\nlet doc = null;\nlet focusPath = [];\nlet matchFn = defaultMatchFn;\n/**\n * Used to build up call arguments. Each patch call gets a separate copy, so\n * this works with nested calls to patch.\n */\nlet argsBuilder = [];\n/**\n * Used to build up attrs for the an element.\n */\nlet attrsBuilder = [];\n/**\n * TODO(sparhami) We should just export argsBuilder directly when Closure\n * Compiler supports ES6 directly.\n * @returns The Array used for building arguments.\n */\nfunction getArgsBuilder() {\n    return argsBuilder;\n}\n/**\n * TODO(sparhami) We should just export attrsBuilder directly when Closure\n * Compiler supports ES6 directly.\n * @returns The Array used for building arguments.\n */\nfunction getAttrsBuilder() {\n    return attrsBuilder;\n}\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key. This uses the specified match function when creating the patcher.\n * @param matchNode A node to match the data to.\n * @param nameOrCtor The name or constructor to check for.\n * @param key The key used to identify the Node.\n * @return True if the node matches, false otherwise.\n */\nfunction matches(matchNode, nameOrCtor, key) {\n    const data = getData(matchNode, key);\n    return matchFn(matchNode, nameOrCtor, data.nameOrCtor, key, data.key);\n}\n/**\n * Finds the matching node, starting at `node` and looking at the subsequent\n * siblings if a key is used.\n * @param matchNode The node to start looking at.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @returns The matching Node, if any exists.\n */\nfunction getMatchingNode(matchNode, nameOrCtor, key) {\n    if (!matchNode) {\n        return null;\n    }\n    let cur = matchNode;\n    do {\n        if (matches(cur, nameOrCtor, key)) {\n            return cur;\n        }\n    } while (key && (cur = cur.nextSibling));\n    return null;\n}\n/**\n * Clears out any unvisited Nodes in a given range.\n * @param maybeParentNode\n * @param startNode The node to start clearing from, inclusive.\n * @param endNode The node to clear until, exclusive.\n */\nfunction clearUnvisitedDOM(maybeParentNode, startNode, endNode) {\n    const parentNode = maybeParentNode;\n    let child = startNode;\n    while (child !== endNode) {\n        const next = child.nextSibling;\n        parentNode.removeChild(child);\n        context.markDeleted(child);\n        child = next;\n    }\n}\n/**\n * @return The next Node to be patched.\n */\nfunction getNextNode() {\n    if (currentNode) {\n        return currentNode.nextSibling;\n    }\n    else {\n        return currentParent.firstChild;\n    }\n}\n/**\n * Changes to the first child of the current node.\n */\nfunction enterNode() {\n    currentParent = currentNode;\n    currentNode = null;\n}\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nfunction exitNode() {\n    clearUnvisitedDOM(currentParent, getNextNode(), null);\n    currentNode = currentParent;\n    currentParent = currentParent.parentNode;\n}\n/**\n * Changes to the next sibling of the current node.\n */\nfunction nextNode() {\n    currentNode = getNextNode();\n}\n/**\n * Creates a Node and marking it as created.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @return The newly created node.\n */\nfunction createNode(nameOrCtor, key) {\n    let node;\n    if (nameOrCtor === \"#text\") {\n        node = createText(doc);\n    }\n    else {\n        node = createElement(doc, currentParent, nameOrCtor, key);\n    }\n    context.markCreated(node);\n    return node;\n}\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction alignWithDOM(nameOrCtor, key) {\n    nextNode();\n    const existingNode = getMatchingNode(currentNode, nameOrCtor, key);\n    const node = existingNode || createNode(nameOrCtor, key);\n    // If we are at the matching node, then we are done.\n    if (node === currentNode) {\n        return;\n    }\n    // Re-order the node into the right position, preserving focus if either\n    // node or currentNode are focused by making sure that they are not detached\n    // from the DOM.\n    if (focusPath.indexOf(node) >= 0) {\n        // Move everything else before the node.\n        moveBefore(currentParent, node, currentNode);\n    }\n    else {\n        currentParent.insertBefore(node, currentNode);\n    }\n    currentNode = node;\n}\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return The corresponding Element.\n */\nfunction open(nameOrCtor, key) {\n    alignWithDOM(nameOrCtor, key);\n    enterNode();\n    return currentParent;\n}\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n * @returns The Element that was just closed.\n */\nfunction close() {\n    {\n        setInSkip(false);\n    }\n    exitNode();\n    return currentNode;\n}\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n * @returns The Text node that was aligned or created.\n */\nfunction text() {\n    alignWithDOM(\"#text\", null);\n    return currentNode;\n}\n/**\n * @returns The current Element being patched.\n */\nfunction currentElement() {\n    {\n        assertInPatch(\"currentElement\");\n        assertNotInAttributes(\"currentElement\");\n    }\n    return currentParent;\n}\n/**\n * @return The Node that will be evaluated for the next instruction.\n */\nfunction currentPointer() {\n    {\n        assertInPatch(\"currentPointer\");\n        assertNotInAttributes(\"currentPointer\");\n    }\n    // TODO(tomnguyen): assert that this is not null\n    return getNextNode();\n}\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nfunction skip() {\n    {\n        assertNoChildrenDeclaredYet(\"skip\", currentNode);\n        setInSkip(true);\n    }\n    currentNode = currentParent.lastChild;\n}\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param run The function that will run the patch.\n * @param patchConfig The configuration to use for the patch.\n * @returns The created patch function.\n */\nfunction createPatcher(run, patchConfig = {}) {\n    const { matches = defaultMatchFn } = patchConfig;\n    const f = (node, fn, data) => {\n        const prevContext = context;\n        const prevDoc = doc;\n        const prevFocusPath = focusPath;\n        const prevArgsBuilder = argsBuilder;\n        const prevAttrsBuilder = attrsBuilder;\n        const prevCurrentNode = currentNode;\n        const prevCurrentParent = currentParent;\n        const prevMatchFn = matchFn;\n        let previousInAttributes = false;\n        let previousInSkip = false;\n        doc = node.ownerDocument;\n        context = new Context();\n        matchFn = matches;\n        argsBuilder = [];\n        attrsBuilder = [];\n        currentNode = null;\n        currentParent = node.parentNode;\n        focusPath = getFocusedPath(node, currentParent);\n        {\n            previousInAttributes = setInAttributes(false);\n            previousInSkip = setInSkip(false);\n            updatePatchContext(context);\n        }\n        try {\n            const retVal = run(node, fn, data);\n            {\n                assertVirtualAttributesClosed();\n            }\n            return retVal;\n        }\n        finally {\n            context.notifyChanges();\n            doc = prevDoc;\n            context = prevContext;\n            matchFn = prevMatchFn;\n            argsBuilder = prevArgsBuilder;\n            attrsBuilder = prevAttrsBuilder;\n            currentNode = prevCurrentNode;\n            currentParent = prevCurrentParent;\n            focusPath = prevFocusPath;\n            // Needs to be done after assertions because assertions rely on state\n            // from these methods.\n            {\n                setInAttributes(previousInAttributes);\n                setInSkip(previousInSkip);\n                updatePatchContext(context);\n            }\n        }\n    };\n    return f;\n}\n/**\n * Creates a patcher that patches the document starting at node with a\n * provided function. This function may be called during an existing patch operation.\n * @param patchConfig The config to use for the patch.\n * @returns The created function for patching an Element's children.\n */\nfunction createPatchInner(patchConfig) {\n    return createPatcher((node, fn, data) => {\n        currentNode = node;\n        enterNode();\n        fn(data);\n        exitNode();\n        {\n            assertNoUnclosedTags(currentNode, node);\n        }\n        return node;\n    }, patchConfig);\n}\n/**\n * Creates a patcher that patches an Element with the the provided function.\n * Exactly one top level element call should be made corresponding to `node`.\n * @param patchConfig The config to use for the patch.\n * @returns The created function for patching an Element.\n */\nfunction createPatchOuter(patchConfig) {\n    return createPatcher((node, fn, data) => {\n        const startNode = { nextSibling: node };\n        let expectedNextNode = null;\n        let expectedPrevNode = null;\n        {\n            expectedNextNode = node.nextSibling;\n            expectedPrevNode = node.previousSibling;\n        }\n        currentNode = startNode;\n        fn(data);\n        {\n            assertPatchOuterHasParentNode(currentParent);\n            assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);\n        }\n        if (currentParent) {\n            clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);\n        }\n        return startNode === currentNode ? null : currentNode;\n    }, patchConfig);\n}\nconst patchInner = createPatchInner();\nconst patchOuter = createPatchOuter();\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst buffer = [];\nlet bufferStart = 0;\n/**\n * TODO(tomnguyen): This is a bit silly and really needs to be better typed.\n * @param fn A function to call.\n * @param a The first argument to the function.\n * @param b The second argument to the function.\n * @param c The third argument to the function.\n */\nfunction queueChange(fn, a, b, c) {\n    buffer.push(fn);\n    buffer.push(a);\n    buffer.push(b);\n    buffer.push(c);\n}\n/**\n * Flushes the changes buffer, calling the functions for each change.\n */\nfunction flush() {\n    // A change may cause this function to be called re-entrantly. Keep track of\n    // the portion of the buffer we are consuming. Updates the start pointer so\n    // that the next call knows where to start from.\n    const start = bufferStart;\n    const end = buffer.length;\n    bufferStart = end;\n    for (let i = start; i < end; i += 4) {\n        const fn = buffer[i];\n        fn(buffer[i + 1], buffer[i + 2], buffer[i + 3]);\n    }\n    bufferStart = start;\n    truncateArray(buffer, start);\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is cleared out and reused.\n */\nconst prevValuesMap = createMap();\n/**\n * Calculates the diff between previous and next values, calling the update\n * function when an item has changed value. If an item from the previous values\n * is not present in the the next values, the update function is called with a\n * value of `undefined`.\n * @param prev The previous values, alternating name, value pairs.\n * @param next The next values, alternating name, value pairs.\n * @param updateCtx The context for the updateFn.\n * @param updateFn A function to call when a value has changed.\n */\nfunction calculateDiff(prev, next, updateCtx, updateFn) {\n    const isNew = !prev.length;\n    let i = 0;\n    for (; i < next.length; i += 2) {\n        const name = next[i];\n        if (isNew) {\n            prev[i] = name;\n        }\n        else if (prev[i] !== name) {\n            break;\n        }\n        const value = next[i + 1];\n        if (isNew || prev[i + 1] !== value) {\n            prev[i + 1] = value;\n            queueChange(updateFn, updateCtx, name, value);\n        }\n    }\n    // Items did not line up exactly as before, need to make sure old items are\n    // removed. This should be a rare case.\n    if (i < next.length || i < prev.length) {\n        const startIndex = i;\n        for (i = startIndex; i < prev.length; i += 2) {\n            prevValuesMap[prev[i]] = prev[i + 1];\n        }\n        for (i = startIndex; i < next.length; i += 2) {\n            const name = next[i];\n            const value = next[i + 1];\n            if (prevValuesMap[name] !== value) {\n                queueChange(updateFn, updateCtx, name, value);\n            }\n            prev[i] = name;\n            prev[i + 1] = value;\n            delete prevValuesMap[name];\n        }\n        truncateArray(prev, next.length);\n        for (const name in prevValuesMap) {\n            queueChange(updateFn, updateCtx, name, undefined);\n            delete prevValuesMap[name];\n        }\n    }\n    flush();\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n */\nconst ATTRIBUTES_OFFSET = 3;\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is reused.\n * TODO(sparhamI) Scope this to a patch so you can call patch from an attribute\n * update.\n */\nconst prevAttrsMap = createMap();\n/**\n * @param element The Element to diff the attrs for.\n * @param data The NodeData associated with the Element.\n */\nfunction diffAttrs(element, data) {\n    const attrsBuilder = getAttrsBuilder();\n    const prevAttrsArr = data.getAttrsArr(attrsBuilder.length);\n    calculateDiff(prevAttrsArr, attrsBuilder, element, updateAttribute);\n    truncateArray(attrsBuilder, 0);\n}\n/**\n * Applies the statics. When importing an Element, any existing attributes that\n * match a static are converted into a static attribute.\n * @param node The Element to apply statics for.\n * @param data The NodeData associated with the Element.\n * @param statics The statics array.\n */\nfunction diffStatics(node, data, statics) {\n    if (data.staticsApplied) {\n        return;\n    }\n    data.staticsApplied = true;\n    if (!statics || !statics.length) {\n        return;\n    }\n    if (data.hasEmptyAttrsArr()) {\n        for (let i = 0; i < statics.length; i += 2) {\n            updateAttribute(node, statics[i], statics[i + 1]);\n        }\n        return;\n    }\n    for (let i = 0; i < statics.length; i += 2) {\n        prevAttrsMap[statics[i]] = i + 1;\n    }\n    const attrsArr = data.getAttrsArr(0);\n    let j = 0;\n    for (let i = 0; i < attrsArr.length; i += 2) {\n        const name = attrsArr[i];\n        const value = attrsArr[i + 1];\n        const staticsIndex = prevAttrsMap[name];\n        if (staticsIndex) {\n            // For any attrs that are static and have the same value, make sure we do\n            // not set them again.\n            if (statics[staticsIndex] === value) {\n                delete prevAttrsMap[name];\n            }\n            continue;\n        }\n        // For any attrs that are dynamic, move them up to the right place.\n        attrsArr[j] = name;\n        attrsArr[j + 1] = value;\n        j += 2;\n    }\n    // Anything after `j` was either moved up already or static.\n    truncateArray(attrsArr, j);\n    for (const name in prevAttrsMap) {\n        updateAttribute(node, name, statics[prevAttrsMap[name]]);\n        delete prevAttrsMap[name];\n    }\n}\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n */\nfunction elementOpenStart(nameOrCtor, key, statics) {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertNotInAttributes(\"elementOpenStart\");\n        setInAttributes(true);\n    }\n    argsBuilder[0] = nameOrCtor;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n}\n/**\n * Allows you to define a key after an elementOpenStart. This is useful in\n * templates that define key after an element has been opened ie\n * `<div key('foo')></div>`.\n * @param key The key to use for the next call.\n */\nfunction key(key) {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertInAttributes(\"key\");\n        assert(argsBuilder);\n    }\n    argsBuilder[1] = key;\n}\n/**\n * Buffers an attribute, which will get applied during the next call to\n * `elementOpen`, `elementOpenEnd` or `applyAttrs`.\n * @param name The of the attribute to buffer.\n * @param value The value of the attribute to buffer.\n */\nfunction attr(name, value) {\n    const attrsBuilder = getAttrsBuilder();\n    {\n        assertInPatch(\"attr\");\n    }\n    attrsBuilder.push(name);\n    attrsBuilder.push(value);\n}\n/**\n * Closes an open tag started with elementOpenStart.\n * @return The corresponding Element.\n */\nfunction elementOpenEnd() {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertInAttributes(\"elementOpenEnd\");\n        setInAttributes(false);\n    }\n    const node = open(argsBuilder[0], argsBuilder[1]);\n    const data = getData(node);\n    diffStatics(node, data, argsBuilder[2]);\n    diffAttrs(node, data);\n    truncateArray(argsBuilder, 0);\n    return node;\n}\n/**\n * @param  nameOrCtor The Element's tag or constructor.\n * @param  key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementOpen(nameOrCtor, key, \n// Ideally we could tag statics and varArgs as an array where every odd\n// element is a string and every even element is any, but this is hard.\nstatics, ...varArgs) {\n    {\n        assertNotInAttributes(\"elementOpen\");\n        assertNotInSkip(\"elementOpen\");\n    }\n    elementOpenStart(nameOrCtor, key, statics);\n    for (let i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        attr(arguments[i], arguments[i + 1]);\n    }\n    return elementOpenEnd();\n}\n/**\n * Applies the currently buffered attrs to the currently open element. This\n * clears the buffered attributes.\n */\nfunction applyAttrs() {\n    const node = currentElement();\n    const data = getData(node);\n    diffAttrs(node, data);\n}\n/**\n * Applies the current static attributes to the currently open element. Note:\n * statics should be applied before calling `applyAtrs`.\n * @param statics The statics to apply to the current element.\n */\nfunction applyStatics(statics) {\n    const node = currentElement();\n    const data = getData(node);\n    diffStatics(node, data, statics);\n}\n/**\n * Closes an open virtual Element.\n *\n * @param nameOrCtor The Element's tag or constructor.\n * @return The corresponding Element.\n */\nfunction elementClose(nameOrCtor) {\n    {\n        assertNotInAttributes(\"elementClose\");\n    }\n    const node = close();\n    {\n        assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n    }\n    return node;\n}\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementVoid(nameOrCtor, key, \n// Ideally we could tag statics and varArgs as an array where every odd\n// element is a string and every even element is any, but this is hard.\nstatics, ...varArgs) {\n    elementOpen.apply(null, arguments);\n    return elementClose(nameOrCtor);\n}\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param value The value of the Text.\n * @param varArgs\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return The corresponding text node.\n */\nfunction text$1(value, ...varArgs) {\n    {\n        assertNotInAttributes(\"text\");\n        assertNotInSkip(\"text\");\n    }\n    const node = text();\n    const data = getData(node);\n    if (data.text !== value) {\n        data.text = value;\n        let formatted = value;\n        for (let i = 1; i < arguments.length; i += 1) {\n            /*\n             * Call the formatter function directly to prevent leaking arguments.\n             * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n             */\n            const fn = arguments[i];\n            formatted = fn(formatted);\n        }\n        // Setting node.data resets the cursor in IE/Edge.\n        if (node.data !== formatted) {\n            node.data = formatted;\n        }\n    }\n    return node;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.attributes = attributes;\nexports.alignWithDOM = alignWithDOM;\nexports.close = close;\nexports.createPatchInner = createPatchInner;\nexports.createPatchOuter = createPatchOuter;\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.open = open;\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.skip = skip;\nexports.skipNode = nextNode;\nexports.setKeyAttributeName = setKeyAttributeName;\nexports.clearCache = clearCache;\nexports.getKey = getKey;\nexports.importNode = importNode;\nexports.isDataInitialized = isDataInitialized;\nexports.notifications = notifications;\nexports.symbols = symbols;\nexports.applyAttrs = applyAttrs;\nexports.applyStatics = applyStatics;\nexports.attr = attr;\nexports.elementClose = elementClose;\nexports.elementOpen = elementOpen;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpenStart = elementOpenStart;\nexports.elementVoid = elementVoid;\nexports.key = key;\nexports.text = text$1;\n//# sourceMappingURL=bundle.cjs.js.map\n"],"names":["Object","defineProperty","exports","value","keyAttributeName","inAttributes","inSkip","inPatch","assert","val","Error","assertInPatch","functionName","assertNotInAttributes","assertNotInSkip","assertInAttributes","updatePatchContext","newContext","setInAttributes","previous","setInSkip","hasOwnProperty","prototype","Blank","createMap","truncateArray","arr","length","pop","create","symbols","default","applyAttr","el","name","removeAttribute","attrNS","lastIndexOf","getNamespace","setAttributeNS","String","setAttribute","applyProp","setStyleValue","style","prop","indexOf","setProperty","attributes","updateAttribute","type","elStyle","cssText","map","property","call","notifications","nodesCreated","nodesDeleted","Context","constructor","created","deleted","markCreated","node","push","markDeleted","notifyChanges","this","isElement","nodeType","getRootNode","Node","cur","prev","parentNode","getFocusedPath","root","activeElement","isDocumentRoot","getActiveElement","contains","ancestry","n","getAncestry","NodeData","nameOrCtor","key","text","_attrsArr","staticsApplied","hasEmptyAttrsArr","attrs","getAttrsArr","initialAllocationSize","Array","createArray","initData","data","importSingleNode","fallbackKey","nodeName","localName","keyAttrName","keyAttr","getAttribute","attrsArr","i","j","attr","recordAttributes","getData","createElement","doc","parent","namespace","tag","namespaceURI","getNamespaceForTag","createElementNS","defaultMatchFn","matchNode","expectedNameOrCtor","expectedKey","context","currentNode","currentParent","focusPath","matchFn","argsBuilder","attrsBuilder","getArgsBuilder","getAttrsBuilder","matches","clearUnvisitedDOM","maybeParentNode","startNode","endNode","child","next","nextSibling","removeChild","getNextNode","firstChild","enterNode","exitNode","nextNode","createNode","createTextNode","createText","alignWithDOM","getMatchingNode","referenceNode","insertReferenceNode","insertBefore","moveBefore","open","close","currentElement","createPatcher","run","patchConfig","fn","prevContext","prevDoc","prevFocusPath","prevArgsBuilder","prevAttrsBuilder","prevCurrentNode","prevCurrentParent","prevMatchFn","previousInAttributes","previousInSkip","ownerDocument","retVal","assertVirtualAttributesClosed","createPatchInner","openElement","openTags","toLowerCase","join","assertNoUnclosedTags","createPatchOuter","expectedNextNode","expectedPrevNode","previousSibling","console","warn","maybeStartNode","maybeCurrentNode","wasUpdated","wasChanged","assertPatchElementNoExtras","patchInner","patchOuter","buffer","bufferStart","queueChange","a","b","c","prevValuesMap","calculateDiff","updateCtx","updateFn","isNew","startIndex","undefined","start","end","flush","prevAttrsMap","diffAttrs","element","diffStatics","statics","staticsIndex","elementOpenStart","elementOpenEnd","elementOpen","varArgs","arguments","elementClose","currentNameOrCtor","assertCloseMatchesOpenTag","previousNode","assertNoChildrenDeclaredYet","lastChild","clearCache","importNode","Boolean","apply","formatted"],"mappings":"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"}