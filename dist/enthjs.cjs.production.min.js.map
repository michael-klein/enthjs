{"version":3,"file":"enthjs.cjs.production.min.js","sources":["../src/reactivity/reactivity.ts","../src/dom/directive.ts","../src/dom/html.ts","../src/scheduler/scheduler.ts","../src/dom/render.ts","../src/dom/component.ts","../src/dom/directives/text.ts","../src/dom/directives/clss.ts","../src/dom/directives/attr.ts","../src/dom/directives/on.ts","../src/dom/directives/prop.ts","../src/dom/directives/input.ts","../src/dom/directives/sub.ts","../src/dom/directives/frag.ts","../src/dom/directives/list.ts","../src/dom/default_fallback.ts","../src/dom/create_event.ts"],"sourcesContent":["const isProxyMap: WeakSet<object> = new WeakSet();\nexport function proxify(\n  obj: any,\n  onChange: () => void,\n  hooks: {\n    set?: (obj: any, prop: string | number | symbol, value: any) => any;\n    get?: (obj: any, prop: string | number | symbol) => void;\n  } = {}\n): any {\n  let initialized = false;\n  let onChangeWrapped = () => {\n    if (initialized) {\n      onChange();\n    }\n  };\n  Object.keys(obj).forEach(key => {\n    if (typeof obj[key] === 'object' && !isProxyMap.has(obj[key])) {\n      obj[key] = proxify(obj[key], onChange);\n    }\n  });\n  const proxy = new Proxy(obj as any, {\n    get: (obj, prop) => {\n      if (hooks.get) {\n        hooks.get(obj, prop);\n      }\n      return obj[prop];\n    },\n    set: (obj, prop, value) => {\n      if (hooks.set) {\n        value = hooks.set(obj, prop, value);\n      }\n      if (typeof value === 'object' && !isProxyMap.has(value)) {\n        console.log('proxify');\n        value = proxify(value, onChangeWrapped);\n      }\n      if (\n        (obj[prop] !== value || !initialized) &&\n        prop !== '__$p' &&\n        prop !== 'on'\n      ) {\n        obj[prop] = value;\n        onChangeWrapped();\n      }\n      obj[prop] = value;\n      return true;\n    },\n  });\n  isProxyMap.add(proxy);\n  initialized = true;\n  return proxy;\n}\nexport type State<S extends {} = {}> = S & {\n  on: (listener: (value: S) => void) => () => void;\n  merge: (otherState: State<Partial<S>>) => void;\n};\n\nexport const $state = <S extends {} = {}>(\n  initialState: Partial<S> = {}\n): State<S> => {\n  let listeners: ((value: S) => void)[] = [];\n  let canEmit = true;\n  const proxy = proxify(initialState, () => {\n    if (canEmit) {\n      listeners.forEach(l => l(proxy));\n    }\n  });\n  proxy.on = (listener: (value: S) => void): (() => void) => {\n    listeners.push(listener);\n    return () => {\n      const index = listeners.indexOf(listener);\n      if (index > 1) {\n        listeners.splice(index, 1);\n      }\n    };\n  };\n  proxy.merge = (otherState: State<Partial<S>>) => {\n    const performMerge = (value: Partial<S>) => {\n      Object.keys(value).forEach(key => {\n        if (!['on', 'merge'].includes(key)) {\n          proxy[key] = (value as any)[key];\n        }\n      });\n    };\n    otherState.on(value => {\n      performMerge(value);\n    });\n    canEmit = false;\n    performMerge(otherState);\n    canEmit = true;\n  };\n  return proxy;\n};\n","import { DirectiveType } from './html';\n\nexport interface DOMUpdate {\n  node: Node;\n  newNode?: Node;\n  type: DOMUpdateType;\n  value?: string;\n  name?: string;\n}\nexport enum DOMUpdateType {\n  TEXT,\n  REPLACE_NODE,\n  ADD_NODE,\n  PREPEND_NODE,\n  INSERT_BEFORE,\n  INSERT_AFTER,\n  REMOVE,\n  ADD_CLASS,\n  REMOVE_CLASS,\n  SET_ATTRIBUTE,\n  CUSTOM,\n}\n\nexport type DirectiveGenerator<Args extends any[] = any[]> =\n  | Generator<DOMUpdate[] | Promise<DOMUpdate[]> | void, void, Args>\n  | AsyncGenerator<DOMUpdate[] | Promise<DOMUpdate[]> | void, void, Args>;\nexport interface DirectiveGeneratorFactoryThis {\n  type: DirectiveType;\n  container: Node;\n}\nexport type DirectiveGeneratorFactory<\n  N extends Node = Node,\n  Args extends any[] = any[]\n> = (\n  this: DirectiveGeneratorFactoryThis,\n  node: N,\n  ...initialArgs: Args\n) => DirectiveGenerator<Args>;\nexport const IS_DIRECTIVE = Symbol.for('directive');\nexport interface DirectiveResult<\n  N extends Node = any,\n  Args extends any[] = any\n> {\n  [IS_DIRECTIVE]: true;\n  factory: DirectiveGeneratorFactory<N, Args>;\n  args: Args;\n  directive: Directive;\n}\nexport type Directive<N extends Node = Node, Args extends any[] = any[]> = (\n  ...args: Args\n) => DirectiveResult<N, Args>;\nexport function createDirective<\n  Args extends any[],\n  N extends Node = any,\n  F extends DirectiveGeneratorFactory<N, Args> = DirectiveGeneratorFactory<\n    N,\n    Args\n  >\n>(\n  factory: F\n): F extends (node: N, ...initialArgs: infer A) => DirectiveGenerator<any>\n  ? Directive<N, A>\n  : never {\n  return ((factory: F) => {\n    const directive = function(...args: Args) {\n      return {\n        [IS_DIRECTIVE]: true,\n        factory,\n        args,\n        directive,\n      };\n    } as any;\n    return directive;\n  })(factory);\n}\n","import { IS_DIRECTIVE, DirectiveResult } from './directive';\n\nconst isLetter = (c: string): boolean => {\n  return c.toLowerCase() != c.toUpperCase();\n};\n\nexport enum DirectiveType {\n  TEXT,\n  ATTRIBUTE,\n  ATTRIBUTE_VALUE,\n}\n\nexport interface DynamicData {\n  directive?: DirectiveResult;\n  staticValue?: any;\n  marker?: string;\n  type?: DirectiveType;\n  attribute?: string;\n  dx?: number;\n  staticParts: TemplateStringsArray;\n}\n\nexport const getTextMarker = (id: number): string => {\n  return `tm-${id}`;\n};\n\nexport const getAttributeMarker = (id: number): string => {\n  return `data-am-${id}`;\n};\nexport const IS_HTML_RESULT = Symbol.for('html_result');\nexport interface HTMLResult {\n  dynamicData: DynamicData[];\n  staticParts: TemplateStringsArray;\n  key?: string;\n  [IS_HTML_RESULT]: true;\n  template?: HTMLTemplateElement;\n}\nexport type HTML = typeof html;\nexport function isDirective(thing: any): boolean {\n  return typeof thing === 'object' && thing[IS_DIRECTIVE];\n}\nlet resultCache: WeakMap<TemplateStringsArray, HTMLResult> = new WeakMap();\nexport const html = (\n  staticParts: TemplateStringsArray,\n  ...dynamicParts: any[]\n): HTMLResult => {\n  let result: HTMLResult = resultCache.get(staticParts);\n  if (!result) {\n    let appendedStatic: string = '';\n    const dynamicData: DynamicData[] = [];\n    for (let i = 0; i < dynamicParts.length; i++) {\n      const dynamicPart = dynamicParts[i];\n      const staticPart = staticParts[i];\n      appendedStatic += staticPart;\n      let dx: number = 0;\n      let id = dynamicData.push({ staticParts }) - 1;\n      const currentDynamicData: DynamicData = dynamicData[id];\n      if (isDirective(dynamicPart)) {\n        currentDynamicData.directive = dynamicPart;\n      } else {\n        currentDynamicData.staticValue = dynamicPart;\n      }\n      let si = appendedStatic.length + 1;\n      let attributeValueMode = false;\n      let attributeMode = false;\n      let attributeNameFound = false;\n      let attributeName = '';\n      while (si--) {\n        dx++;\n        const char = appendedStatic.charAt(si);\n        const nextChar = appendedStatic.charAt(si - 1);\n        const nextNextChar = appendedStatic.charAt(si - 2);\n        if (char === '>' || si === 0) {\n          let marker = getTextMarker(id);\n          currentDynamicData.marker = `<${marker}>&zwnj;</${marker}>`;\n          currentDynamicData.type = DirectiveType.TEXT;\n          break;\n        }\n        if (\n          char === '\"' &&\n          nextChar === '=' &&\n          isLetter(nextNextChar) &&\n          !attributeMode\n        ) {\n          attributeValueMode = true;\n          continue;\n        }\n        if (char === '\"' && nextNextChar !== '=' && !attributeValueMode) {\n          attributeValueMode = false;\n          attributeMode = true;\n          continue;\n        }\n        if (\n          attributeValueMode &&\n          char !== '\"' &&\n          char !== '=' &&\n          !attributeNameFound\n        ) {\n          if (char !== ' ') {\n            attributeName = char + attributeName;\n          } else {\n            attributeNameFound = true;\n          }\n        }\n        if (char === '<' && attributeValueMode) {\n          currentDynamicData.marker = getAttributeMarker(id);\n          currentDynamicData.type = DirectiveType.ATTRIBUTE_VALUE;\n          currentDynamicData.attribute = attributeName;\n          break;\n        }\n        if (char === '<' && !attributeValueMode) {\n          currentDynamicData.marker = getAttributeMarker(id);\n          currentDynamicData.type = DirectiveType.ATTRIBUTE;\n          break;\n        }\n      }\n      currentDynamicData.dx = dx;\n    }\n    appendedStatic += staticParts[staticParts.length - 1];\n    result = {\n      dynamicData,\n      staticParts,\n      [IS_HTML_RESULT]: true,\n    };\n    resultCache.set(staticParts, result);\n  } else {\n    result = {\n      ...result,\n      dynamicData: result.dynamicData.map((data, id) => {\n        if (!isDirective(dynamicParts[id])) {\n          return {\n            ...data,\n            directive: undefined,\n            staticValue: dynamicParts[id],\n          };\n        } else {\n          return {\n            ...data,\n            staticValue: undefined,\n            directive: dynamicParts[id],\n          };\n        }\n      }),\n    };\n  }\n  return result;\n};\n","export enum PriorityLevel {\n  IMMEDIATE = 0, //synchronous\n  USER_BLOCKING = 250, //.25s timeout\n  NORMAL = 5000, // 5s timeout\n  LOW = 10000, // 10s timeout\n  IDLE = 99999999, // no timeout (run only when nothing else is scheduled)\n}\ntype ScheduledJob = [() => void, number];\nlet scheduledJobs: ScheduledJob[] = [];\nlet schedulerRunning: boolean = false;\nconst MAX_ELAPSED: number = 17;\nconst processJobQueue = (\n  queue: ScheduledJob[],\n  now: number\n): ScheduledJob[] => {\n  let index = 0;\n  for (let length = queue.length; index < length; index++) {\n    const totalElapsed: number = Date.now() - now;\n    const [cb, latestEndTime] = queue[index];\n    if (now >= latestEndTime || totalElapsed < MAX_ELAPSED) {\n      cb();\n    } else {\n      break;\n    }\n  }\n  return queue.slice(index);\n};\nconst processScheduledJobs = () => {\n  const now: number = Date.now();\n  console.log(scheduledJobs.length);\n  scheduledJobs = processJobQueue(\n    scheduledJobs.sort((a, b) => (a[1] < b[1] ? -1 : 1)),\n    now\n  );\n  if (scheduledJobs.length > 0) {\n    requestAnimationFrame(processScheduledJobs);\n  } else {\n    schedulerRunning = false;\n  }\n};\nexport const schedule = (\n  cb: () => void,\n  priority: PriorityLevel = PriorityLevel.NORMAL\n): Promise<void> => {\n  if (priority === PriorityLevel.IMMEDIATE) {\n    cb();\n  } else {\n    return new Promise(resolve => {\n      scheduledJobs.push([\n        () => {\n          cb();\n          resolve();\n        },\n        Date.now() + priority,\n      ]);\n      if (!schedulerRunning) {\n        requestAnimationFrame(processScheduledJobs);\n        schedulerRunning = true;\n      }\n    });\n  }\n  return Promise.resolve();\n};\nexport type Schedule = typeof schedule;\n","import {\n  HTMLResult,\n  DirectiveType,\n  getTextMarker,\n  getAttributeMarker,\n  DynamicData,\n} from './html';\nimport { DOMUpdateType, DirectiveGenerator } from './directive';\nimport { schedule, PriorityLevel } from '../scheduler/scheduler';\n\nconst renderedNodesMap: WeakMap<Node, Node[]> = new WeakMap();\nexport const clear = (container: HTMLElement) => {\n  if (renderedNodesMap.has(container)) {\n    renderedNodesMap\n      .get(container)\n      .forEach(node => container.removeChild(node));\n    renderedNodesMap.delete(container);\n  }\n};\nexport type Fallback = (data: DynamicData) => DynamicData;\nlet currentFallback: Fallback = data => data;\nexport function defineFallback(fallback: Fallback): void {\n  currentFallback = fallback;\n}\n\nconst insertAttributeMarker = (\n  marker: string,\n  si: number,\n  appendedStatic: string\n): string => {\n  while (si++) {\n    const char = appendedStatic.charAt(si);\n    if (!char) {\n      break;\n    }\n    if (char === ' ') {\n      return (\n        appendedStatic.slice(0, si) + ' ' + marker + appendedStatic.slice(si)\n      );\n    }\n  }\n  return appendedStatic;\n};\n\nfunction createTemplate(htmlResult: HTMLResult): HTMLTemplateElement {\n  let appendedStatic: string = '';\n  const { dynamicData, staticParts } = htmlResult;\n  for (let i = 0; i < dynamicData.length; i++) {\n    let data = applyFallback(dynamicData[i], currentFallback);\n    const staticPart = staticParts[i];\n    appendedStatic += staticPart;\n    if (data.staticValue) {\n      appendedStatic += data.staticValue;\n    } else {\n      switch (data.type) {\n        case DirectiveType.TEXT:\n          appendedStatic += data.marker;\n          break;\n        case DirectiveType.ATTRIBUTE_VALUE:\n        case DirectiveType.ATTRIBUTE:\n          appendedStatic = insertAttributeMarker(\n            data.marker,\n            appendedStatic.length + 1 - data.dx,\n            appendedStatic\n          );\n          break;\n      }\n    }\n  }\n  appendedStatic += staticParts[staticParts.length - 1];\n  const template = document.createElement('template');\n  template.innerHTML = appendedStatic.trim();\n  return template;\n}\nexport type DirectiveFallback = (data: DynamicData) => DynamicData;\nexport interface DirectiveFallbacks {\n  [DirectiveType.ATTRIBUTE]: DirectiveFallback;\n}\nconst generatorMap: WeakMap<Node, DirectiveGenerator[]> = new WeakMap();\nfunction processTemplate(\n  template: HTMLTemplateElement,\n  container: Node,\n  htmlResult: HTMLResult\n): void {\n  const generators: DirectiveGenerator[] = [];\n  generatorMap.set(container, generators);\n  const fragment = template.content;\n  htmlResult.template = template.cloneNode(true) as HTMLTemplateElement;\n  const { dynamicData } = htmlResult;\n\n  dynamicData.forEach((data, id) => {\n    if (data.directive) {\n      switch (data.type) {\n        case DirectiveType.TEXT:\n          const textMarker = getTextMarker(id);\n          const placeholder = fragment.querySelector(textMarker);\n          let textNode;\n          let isTextArea = false;\n          if (placeholder) {\n            textNode = placeholder.firstChild;\n          } else {\n            isTextArea = true;\n            const textareas = fragment.querySelectorAll('textarea');\n            for (let i = 0; i < textareas.length; i++) {\n              const area = textareas[i];\n              if (area.innerText.includes(textMarker)) {\n                textNode = area.firstChild;\n                break;\n              }\n            }\n          }\n\n          generators[id] = data.directive.factory.call(\n            {\n              type: data.type,\n              container,\n            },\n            textNode,\n            ...data.directive.args\n          );\n          if (!isTextArea) {\n            placeholder.parentNode.replaceChild(textNode, placeholder);\n          }\n          break;\n        case DirectiveType.ATTRIBUTE:\n        case DirectiveType.ATTRIBUTE_VALUE:\n          const marker = getAttributeMarker(id);\n          const node = fragment.querySelector(`[${marker}]`);\n          generators[id] = data.directive.factory.call(\n            {\n              type: data.type,\n              container,\n            },\n            node,\n            ...data.directive.args\n          );\n          node.removeAttribute(marker);\n      }\n    }\n  });\n  renderedNodesMap.set(container, Array.from(fragment.childNodes));\n}\n\nfunction applyFallback(data: DynamicData, fallback: Fallback): DynamicData {\n  if (!data.directive) {\n    Object.assign(data, fallback(data));\n    if (data.directive) {\n      data.staticValue = undefined;\n    }\n  }\n  return data;\n}\n\ninterface CachedData {\n  staticParts?: TemplateStringsArray;\n  states?: any[];\n  prevValues?: any[][];\n}\nconst containerDataCache: WeakMap<Node, CachedData> = new WeakMap();\nexport const render = (\n  container: Node,\n  htmlResult: HTMLResult\n): Promise<void> => {\n  let fragment: DocumentFragment;\n  let init = false;\n  const dataCache: CachedData = containerDataCache.get(container) || {};\n  containerDataCache.set(container, dataCache);\n  if (!renderedNodesMap.has(container)) {\n    init = true;\n    const template = createTemplate(htmlResult);\n    processTemplate(template, container, htmlResult);\n    fragment = template.content;\n  }\n  const generators: DirectiveGenerator[] = generatorMap.get(container);\n\n  if (dataCache.staticParts !== htmlResult.staticParts) {\n    dataCache.staticParts = htmlResult.staticParts;\n    dataCache.states = [];\n    dataCache.prevValues = [];\n  }\n  const promise = Promise.all(\n    htmlResult.dynamicData.map(async (data, id) => {\n      if (!dataCache.prevValues[id]) {\n        dataCache.prevValues[id] = [];\n      }\n      data = applyFallback(data, currentFallback);\n      if (data.directive) {\n        if (\n          dataCache.prevValues[id].length !== data.directive.args.length ||\n          dataCache.prevValues[id].findIndex(\n            (arg, index) =>\n              data.directive.args[index] !== arg ||\n              data.directive.args[index] instanceof Object\n          ) > -1\n        ) {\n          if (dataCache.states[id] === undefined) {\n            dataCache.states[id] = {};\n          }\n          const result = await generators[id].next(data.directive.args);\n          const domUpdates = await result.value;\n          dataCache.prevValues[id].length = 0;\n          dataCache.prevValues[id].push(...data.directive.args);\n          if (domUpdates && domUpdates.length > 0) {\n            return schedule(\n              () => {\n                domUpdates.forEach(d => {\n                  switch (d.type) {\n                    case DOMUpdateType.TEXT:\n                      d.node.textContent = d.value;\n                      break;\n                    case DOMUpdateType.ADD_NODE:\n                      d.node.appendChild(d.newNode);\n                      break;\n                    case DOMUpdateType.PREPEND_NODE:\n                      if (d.node.firstChild) {\n                        d.node.insertBefore(d.newNode, d.node.firstChild);\n                      } else {\n                        d.node.appendChild(d.newNode);\n                      }\n                      break;\n                    case DOMUpdateType.REPLACE_NODE:\n                      d.node.parentNode.replaceChild(d.newNode, d.node);\n                      break;\n                    case DOMUpdateType.INSERT_BEFORE:\n                      d.node.parentNode.insertBefore(d.newNode, d.node);\n                      break;\n                    case DOMUpdateType.INSERT_AFTER:\n                      if (d.node.nextSibling) {\n                        d.node.parentNode.insertBefore(\n                          d.newNode,\n                          d.node.nextSibling\n                        );\n                      } else {\n                        d.node.parentNode.appendChild(d.newNode);\n                      }\n                      break;\n                    case DOMUpdateType.REMOVE:\n                      d.node.parentNode.removeChild(d.node);\n                      break;\n                    case DOMUpdateType.ADD_CLASS:\n                      (d.node as HTMLElement).classList.add(d.value);\n                      break;\n                    case DOMUpdateType.REMOVE_CLASS:\n                      (d.node as HTMLElement).classList.remove(d.value);\n                      break;\n                    case DOMUpdateType.SET_ATTRIBUTE:\n                      (d.node as HTMLElement).setAttribute(d.name, d.value);\n                      break;\n                  }\n                });\n              },\n              init ? PriorityLevel.IMMEDIATE : undefined\n            );\n          }\n        }\n      }\n    })\n  ).then(() => {});\n  if (fragment) {\n    container.appendChild(fragment);\n  }\n  return promise;\n};\n","import { HTMLResult } from './html';\nimport { State, $state, proxify } from '../reactivity/reactivity';\nimport { render } from './render';\nimport { schedule, PriorityLevel } from '../scheduler/scheduler';\n\nexport type ComponentGenerator = Generator<() => HTMLResult>;\nexport type ComponentGeneratorFactory<StateType extends {}> = (\n  state: State<StateType>\n) => ComponentGenerator;\n\nexport type ConnectedListener = () => void | (() => void);\n\nconst COMPONENT_CONTEXT = Symbol.for('component_context');\ninterface SideEffect {\n  cb: ConnectedListener;\n  cleanUp?: () => void;\n  deps: () => any[];\n  prevDeps?: any[];\n  canRun?: boolean;\n}\ninterface ComponentContext {\n  connectedListeners: ConnectedListener[];\n  sideEffects: SideEffect[];\n  host: HTMLElement;\n}\nfunction getContext(): ComponentContext {\n  if (window[COMPONENT_CONTEXT]) {\n    return window[COMPONENT_CONTEXT];\n  }\n  return undefined;\n}\nexport function getHost<E extends HTMLElement>(): E {\n  const context = getContext();\n  if (context) {\n    return context.host as E;\n  }\n  throw 'getHost can only be called in the setup phase!';\n}\nexport function sideEffect(cb: ConnectedListener, deps?: () => any[]): void {\n  const context = getContext();\n  if (context) {\n    context.sideEffects.push({ cb, deps });\n  }\n}\nexport function connected(cb: ConnectedListener): void {\n  const context = getContext();\n  if (context) {\n    context.connectedListeners.push(cb);\n  }\n}\ndeclare global {\n  interface Window {\n    [COMPONENT_CONTEXT]: ComponentContext;\n  }\n}\n\nconst observerMap: WeakMap<HTMLElement, MutationObserver> = new WeakMap();\n\nconst addObserver = (\n  element: HTMLElement,\n  onChange: (name: string, value: string) => void\n): void => {\n  if (!observerMap.has(element)) {\n    const observer = new MutationObserver((mutationsList: MutationRecord[]) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === 'attributes') {\n          onChange(\n            mutation.attributeName,\n            element.getAttribute(mutation.attributeName)\n          );\n        }\n      }\n    });\n    observerMap.set(element, observer);\n  }\n};\n\nconst startObserving = (element: HTMLElement) => {\n  if (observerMap.has(element)) {\n    observerMap.get(element).observe(element, { attributes: true });\n  }\n};\n\nconst stopObserving = (element: HTMLElement) => {\n  if (observerMap.has(element)) {\n    observerMap.get(element).disconnect();\n  }\n};\n\nfunction createPropertyProxy(element: any, queueRender: () => void) {\n  const accessedProps: string[] = [];\n  const $properties = proxify({}, () => {}, {\n    set: (obj, prop: any, value) => {\n      if (obj[prop] !== value && accessedProps.includes(prop)) {\n        queueRender();\n      }\n      return value;\n    },\n    get: (obj, prop: any) => {\n      if (!obj[prop]) {\n        obj[prop] = element[prop] || undefined;\n      }\n      if (!accessedProps.includes(prop)) {\n        accessedProps.push(prop);\n        Object.defineProperty(element, prop, {\n          get: () => obj[prop],\n          set: (value: any) => {\n            if (obj[prop] !== value) {\n              obj[prop] = value;\n              queueRender();\n            }\n          },\n        });\n      }\n    },\n  });\n  return $properties;\n}\n\nfunction createAttributeProxy(element: HTMLElement, queueRender: () => void) {\n  const accessedAttributes: string[] = [];\n  const $attributes = proxify({}, () => {}, {\n    set: (obj, prop, value) => {\n      if (obj[prop] !== value) {\n        schedule(() => {\n          element.setAttribute(prop as string, value);\n        });\n        queueRender();\n      }\n      return value;\n    },\n    get: (obj, prop: any) => {\n      if (!obj[prop]) {\n        obj[prop] = element.getAttribute(prop) || undefined;\n      }\n      if (!accessedAttributes.includes(prop)) {\n        accessedAttributes.push(prop);\n      }\n      return obj[prop];\n    },\n  });\n  addObserver(element, (name, value) => {\n    if (accessedAttributes.includes(name)) {\n      $attributes[name] = value;\n    }\n  });\n  return $attributes;\n}\n\nexport function component<\n  StateValueType extends {} = { [key: string]: any },\n  StateType extends StateValueType & {\n    attributes: { [key: string]: string };\n    properties: { [key: string]: any };\n  } = StateValueType & {\n    attributes: { [key: string]: string };\n    properties: { [key: string]: any };\n  },\n  S extends State<StateType> = State<StateType>\n>(name: string, factory: ComponentGeneratorFactory<StateType>): void {\n  customElements.define(\n    name,\n    class extends HTMLElement {\n      private disconnectedListeners: (() => void)[] = [];\n      private generator: ComponentGenerator;\n      private context: ComponentContext = {\n        connectedListeners: [],\n        sideEffects: [],\n        host: this,\n      };\n      private $s: S;\n      private stopRenderLoop: () => void;\n      private connected: boolean = false;\n      private renderPromise: Promise<void>;\n\n      constructor() {\n        super();\n        window[COMPONENT_CONTEXT] = this.context;\n        this.attachShadow({ mode: 'open' });\n        this.$s = $state<S>({\n          attributes: createAttributeProxy(this, () => this.queueRender()),\n          properties: createPropertyProxy(this, () => this.queueRender()),\n        } as Partial<S>);\n        this.generator = factory(this.$s);\n      }\n\n      private canRunSideEffect(sideEffect: SideEffect): boolean {\n        sideEffect.canRun =\n          sideEffect.canRun || !sideEffect.deps || !sideEffect.prevDeps;\n        if (!sideEffect.canRun) {\n          const deps = sideEffect.deps();\n          if (sideEffect.prevDeps) {\n            if (\n              deps.findIndex((dep, key) => sideEffect.prevDeps[key] !== dep) >\n              -1\n            ) {\n              sideEffect.canRun = true;\n            }\n          } else {\n            sideEffect.canRun = true;\n          }\n          sideEffect.prevDeps = deps;\n        } else {\n          if (sideEffect.deps) {\n            sideEffect.prevDeps = sideEffect.deps();\n          }\n        }\n        return sideEffect.canRun;\n      }\n\n      private async runSideEffects(): Promise<void> {\n        const promises: Promise<void>[] = [];\n        for (const sideEffect of this.context.sideEffects) {\n          if (this.canRunSideEffect(sideEffect)) {\n            sideEffect.canRun = undefined;\n            promises.push(\n              new Promise(async resolve => {\n                await schedule(() => {\n                  sideEffect.cleanUp = sideEffect.cb() as () => void;\n                }, PriorityLevel.LOW);\n                resolve();\n              })\n            );\n          }\n        }\n        await Promise.all(promises);\n      }\n\n      private async runCleanUps(force: boolean = false): Promise<void> {\n        const promises: Promise<void>[] = [];\n        for (const sideEffect of this.context.sideEffects) {\n          if (this.canRunSideEffect(sideEffect) || force) {\n            if (sideEffect.cleanUp) {\n              promises.push(\n                new Promise(async resolve => {\n                  await schedule(() => {\n                    sideEffect.cleanUp();\n                    sideEffect.cleanUp = undefined;\n                  }, PriorityLevel.LOW);\n                  resolve();\n                })\n              );\n            }\n          }\n        }\n        await Promise.all(promises);\n      }\n\n      private nextQueued = false;\n      private async queueRender(): Promise<void> {\n        if (!this.renderPromise) {\n          const value = this.generator.next().value;\n          window[COMPONENT_CONTEXT] = undefined;\n          if (value) {\n            this.renderPromise = new Promise(async resolve => {\n              await this.runCleanUps();\n              await render(this.shadowRoot, value());\n              await this.runSideEffects();\n              this.renderPromise = undefined;\n              if (this.nextQueued) {\n                this.nextQueued = false;\n                this.queueRender();\n              }\n              resolve();\n            });\n          }\n        } else {\n          this.nextQueued = true;\n        }\n      }\n\n      public connectedCallback(): void {\n        if (!this.connected) {\n          this.queueRender();\n          this.stopRenderLoop = this.$s.on(() => {\n            this.queueRender();\n          });\n          startObserving(this);\n        }\n        this.disconnectedListeners = this.context.connectedListeners\n          .map(cb => cb())\n          .filter(l => l) as (() => void)[];\n      }\n\n      public async disconnectedCallback(): Promise<void> {\n        if (this.connected) {\n          stopObserving(this);\n          if (this.stopRenderLoop) {\n            this.stopRenderLoop();\n          }\n          this.connected = false;\n          this.disconnectedListeners.forEach(cb => cb());\n          this.disconnectedListeners = [];\n          await this.renderPromise;\n          this.runCleanUps(true);\n          this.context.sideEffects.forEach(sideEffect => {\n            sideEffect.prevDeps = undefined;\n          });\n        }\n      }\n    }\n  );\n}\n","import { createDirective, DOMUpdateType } from '../directive';\nimport { DirectiveType } from '../html';\n\nexport const text = createDirective(function*(node: Text, value: string) {\n  if (this.type === DirectiveType.TEXT) {\n    for (;;) {\n      const result = yield [\n        {\n          node,\n          value,\n          type: DOMUpdateType.TEXT,\n        },\n      ];\n      value = result[0];\n    }\n  }\n});\n","import { createDirective, DOMUpdate, DOMUpdateType } from '../directive';\n\nexport const clss = createDirective(function*(node: Node, classes: string) {\n  if (node instanceof HTMLElement) {\n    let oldClasses: string[] = [];\n    for (;;) {\n      const result: DOMUpdate[] = [];\n      oldClasses.forEach(oldCls => {\n        if (!!oldCls) {\n          result.push({\n            type: DOMUpdateType.REMOVE_CLASS,\n            node,\n            value: oldCls,\n          });\n        }\n      });\n      oldClasses = classes.trim().split(' ');\n      oldClasses.forEach(cls => {\n        if (!!cls) {\n          result.push({\n            type: DOMUpdateType.ADD_CLASS,\n            node,\n            value: cls,\n          });\n        }\n      });\n      classes = (yield result)[0];\n    }\n  }\n});\n","import { createDirective, DOMUpdate, DOMUpdateType } from '../directive';\nimport { DirectiveType } from '../html';\n\nexport const attr = createDirective(function*(\n  node: Node,\n  name: string,\n  value: string\n) {\n  if (\n    node instanceof HTMLElement &&\n    (this.type === DirectiveType.ATTRIBUTE ||\n      this.type === DirectiveType.ATTRIBUTE_VALUE)\n  ) {\n    for (;;) {\n      const result: DOMUpdate[] = [\n        {\n          type: DOMUpdateType.SET_ATTRIBUTE,\n          node,\n          value,\n          name,\n        },\n      ];\n      const newArgs = yield result;\n      name = newArgs[0];\n      value = newArgs[1];\n    }\n  }\n});\n","import { createDirective } from '../directive';\nimport { schedule, PriorityLevel } from '../../scheduler/scheduler';\n\nexport const on = createDirective(function*(\n  node: HTMLElement,\n  name: string,\n  cb: <E extends Event>(e: E) => void\n) {\n  node.removeAttribute(name);\n  if (name.startsWith('on')) {\n    name = name.replace('on', '');\n  }\n  const cbRef = {\n    cb,\n  };\n  node.addEventListener(name, e => {\n    schedule(() => cbRef.cb(e), PriorityLevel.IMMEDIATE);\n  });\n  for (;;) {\n    cbRef.cb = (yield)[1];\n  }\n});\n","import { createDirective } from '../directive';\n\nexport const prop = createDirective(function*(\n  node: Node,\n  name: string,\n  value: any\n) {\n  if (node instanceof HTMLElement) {\n    node.removeAttribute(name);\n    for (;;) {\n      if (name.startsWith('.')) {\n        name = name.replace('.', '');\n      }\n      (node as any)[name] = value;\n      const newArgs = yield;\n      name = newArgs[0];\n      value = newArgs[1];\n    }\n  }\n});\n","import { createDirective } from '../directive';\nimport { PriorityLevel, schedule } from '../../scheduler/scheduler';\n\nexport const input = createDirective(function*(\n  node: HTMLElement,\n  cb: (value: string) => void\n) {\n  const cbRef = {\n    cb,\n  };\n  node.addEventListener('input', e => {\n    const value: string = (e.target as HTMLInputElement).value;\n    schedule(() => cbRef.cb(value), PriorityLevel.NORMAL);\n  });\n  for (;;) {\n    cbRef.cb = (yield)[0];\n  }\n});\n","import { createDirective, DOMUpdateType, DOMUpdate } from '../directive';\nimport { HTMLResult, DirectiveType } from '../html';\nimport { render } from '../render';\n\nexport const sub = createDirective(async function*(\n  node: Text,\n  htmlResult: HTMLResult\n) {\n  if (this.type === DirectiveType.TEXT) {\n    const start = document.createComment('');\n    let result: DOMUpdate[] = [\n      {\n        type: DOMUpdateType.REPLACE_NODE,\n        node,\n        newNode: start as any,\n      },\n    ];\n    let prevParts: TemplateStringsArray;\n    let prevFrag: DocumentFragment;\n    let prevChildren: Node[] = [];\n    for (;;) {\n      if (prevParts === htmlResult.staticParts) {\n        await render(prevFrag as any, htmlResult);\n      } else {\n        const frag = document.createDocumentFragment();\n        await render(frag as any, htmlResult);\n        prevChildren.forEach(child => {\n          result.push({\n            type: DOMUpdateType.REMOVE,\n            node: child,\n          });\n        });\n        prevChildren = [];\n        frag.childNodes.forEach(child => {\n          prevChildren.push(child);\n          result.push({\n            type: DOMUpdateType.INSERT_BEFORE,\n            node: start,\n            newNode: child,\n          });\n        });\n        prevParts = htmlResult.staticParts;\n        prevFrag = frag;\n      }\n      htmlResult = (yield result)[0];\n      result = [];\n    }\n  }\n});\n","import { createDirective, DOMUpdateType, DOMUpdate } from '../directive';\n\nexport const frag = createDirective(function*(node: Text, html: string) {\n  if (node.nodeType === 3) {\n    const start = document.createComment('');\n    let result: DOMUpdate[] = [\n      {\n        type: DOMUpdateType.REPLACE_NODE,\n        node,\n        newNode: start as any,\n      },\n    ];\n    const template = document.createElement('template');\n    let prevChildren: Node[] = [];\n    for (;;) {\n      template.innerHTML = html;\n      const frag = template.content;\n      prevChildren.forEach(child => {\n        result.push({\n          type: DOMUpdateType.REMOVE,\n          node: child,\n        });\n      });\n      prevChildren = [];\n      frag.childNodes.forEach(child => {\n        prevChildren.push(child);\n        result.push({\n          type: DOMUpdateType.INSERT_BEFORE,\n          node: start,\n          newNode: child,\n        });\n      });\n      html = (yield result)[0];\n      result = [];\n    }\n  }\n});\n","import { createDirective, DOMUpdateType, DOMUpdate } from '../directive';\nimport { HTMLResult } from '../html';\nimport { render } from '../render';\n\nexport function getKey(htmlResult: HTMLResult): string {\n  for (const dynamicData of htmlResult.dynamicData) {\n    if (dynamicData.attribute === 'key') {\n      dynamicData.directive = key(dynamicData.staticValue);\n      delete dynamicData.staticValue;\n    }\n    if (dynamicData.directive) {\n      if ((dynamicData.directive.directive as any) === key) {\n        return dynamicData.directive.args[0];\n      }\n    }\n  }\n  return htmlResult.staticParts.join();\n}\n\nexport const list = createDirective(function*(\n  node: Text,\n  htmlResults: HTMLResult[]\n) {\n  if (node.nodeType === 3) {\n    const root = document.createDocumentFragment();\n    const end = document.createComment('');\n    const start = document.createComment('');\n    root.appendChild(start);\n    root.appendChild(end);\n    const keyToFragmentsMap: Map<string, [DocumentFragment, Node]> = new Map();\n    let results: DOMUpdate[] = [\n      {\n        type: DOMUpdateType.REPLACE_NODE,\n        node,\n        newNode: root,\n      },\n    ];\n    let oldKeyOrder: string[] = [];\n    for (;;) {\n      const keyOrder: string[] = htmlResults.map(result => {\n        const key = getKey(result);\n        if (!keyToFragmentsMap.has(key)) {\n          const frag = document.createDocumentFragment();\n          render(frag as any, result);\n          if (frag.childNodes.length > 1) {\n            throw 'List items should only render a single node!';\n          }\n          keyToFragmentsMap.set(key, [frag, frag.childNodes[0]]);\n        } else {\n          const frag = keyToFragmentsMap.get(key)[0] as DocumentFragment;\n          render(frag as any, result);\n        }\n        return key;\n      });\n\n      function tryInsert(\n        key: string,\n        oldIndex: number,\n        newIndex: number\n      ): void {\n        const next = keyOrder[newIndex + 1];\n        const nextIndex = keyOrder.indexOf(next);\n        if (nextIndex === -1) {\n          if (\n            oldIndex < Math.max(0, oldKeyOrder.length - 1) ||\n            newIndex === -1\n          ) {\n            results.push({\n              type: DOMUpdateType.INSERT_BEFORE,\n              node: end,\n              newNode: keyToFragmentsMap.get(key)[1],\n            });\n            if (oldIndex > -1) {\n              oldKeyOrder.splice(oldIndex, 1);\n            }\n            oldKeyOrder.push(key);\n          }\n        } else if (oldKeyOrder.indexOf(next) === nextIndex) {\n          results.push({\n            type: DOMUpdateType.INSERT_BEFORE,\n            node: keyToFragmentsMap.get(next)[1],\n            newNode: keyToFragmentsMap.get(key)[1],\n          });\n          if (oldIndex > -1) {\n            oldKeyOrder.splice(oldIndex, 1);\n          }\n          oldKeyOrder.splice(oldKeyOrder.indexOf(next), 0, key);\n        } else {\n          const previous = keyOrder[newIndex - 1];\n          const previousIndex = keyOrder.indexOf(previous);\n          if (previousIndex === -1) {\n            results.push({\n              type: DOMUpdateType.INSERT_AFTER,\n              node: start,\n              newNode: keyToFragmentsMap.get(key)[1],\n            });\n            if (oldIndex > -1) {\n              oldKeyOrder.splice(oldIndex, 1);\n            }\n            oldKeyOrder.unshift(key);\n          } else if (oldKeyOrder.indexOf(previous) === previousIndex) {\n            results.push({\n              type: DOMUpdateType.INSERT_AFTER,\n              node: keyToFragmentsMap.get(previous)[1],\n              newNode: keyToFragmentsMap.get(key)[1],\n            });\n            if (oldIndex > -1) {\n              oldKeyOrder.splice(oldIndex, 1);\n            }\n            oldKeyOrder.splice(oldKeyOrder.indexOf(next) + 1, 0, key);\n          }\n        }\n      }\n\n      function handleKey(key: string): void {\n        const oldIndex = oldKeyOrder.indexOf(key);\n        const newIndex = keyOrder.indexOf(key);\n        if (oldIndex !== newIndex) {\n          if (oldIndex > -1 && newIndex === -1) {\n            results.push({\n              type: DOMUpdateType.REMOVE,\n              node: keyToFragmentsMap.get(key)[1],\n            });\n            oldKeyOrder.splice(oldIndex, 1);\n          } else {\n            tryInsert(key, oldIndex, newIndex);\n          }\n        }\n      }\n      let j = 0;\n      while (keyOrder.join() !== oldKeyOrder.join()) {\n        j++;\n        if (j > keyOrder.length) {\n          console.log('break');\n          break;\n        }\n        const oldKeyOrderCopy = [...oldKeyOrder];\n        const keyOrderCopy = [...keyOrder];\n        for (\n          let i = 0;\n          i < Math.max(oldKeyOrder.length, keyOrder.length);\n          i++\n        ) {\n          let key = oldKeyOrderCopy[i];\n          if (key && keyOrder.indexOf(key) !== i) {\n            handleKey(key);\n          }\n          key = keyOrderCopy[i];\n          if (key && oldKeyOrder.indexOf(key) !== i) {\n            handleKey(key);\n          }\n        }\n      }\n      htmlResults = (yield results)[0];\n      results = [];\n    }\n  }\n});\n\nexport const key = createDirective(function*(\n  node: HTMLElement,\n  _keyName: string\n) {\n  node.removeAttribute('key');\n});\n","import { defineFallback } from './render';\nimport { DirectiveType, IS_HTML_RESULT } from './html';\nimport { attr } from './directives/attr';\nimport { text } from './directives/text';\nimport { sub } from './directives/sub';\nimport { on } from './directives/on';\nimport { prop } from './directives/prop';\nimport { list, key } from './directives/list';\n\nexport function applyDefaultFallback(): void {\n  defineFallback(data => {\n    if (data.type === DirectiveType.TEXT) {\n      if (\n        typeof data.staticValue === 'string' ||\n        typeof data.staticValue === 'number'\n      ) {\n        data.directive = text(data.staticValue + '') as any;\n      } else if (\n        data.staticValue instanceof Array &&\n        data.staticValue.findIndex(\n          item => !(typeof item === 'object' && item[IS_HTML_RESULT])\n        ) === -1\n      ) {\n        data.directive = list(data.staticValue);\n      }\n    }\n    if (data.type === DirectiveType.ATTRIBUTE_VALUE) {\n      if (data.attribute.startsWith('on')) {\n        data.directive = on(data.attribute, data.staticValue) as any;\n      } else if (data.attribute.startsWith('.')) {\n        data.directive = prop(data.attribute, data.staticValue) as any;\n      } else if (data.attribute === 'key') {\n        data.directive = key(data.staticValue) as any;\n      } else {\n        data.directive = attr(data.attribute, data.staticValue + '') as any;\n      }\n    }\n\n    if (\n      data.type === DirectiveType.TEXT &&\n      typeof data.staticValue === 'object' &&\n      data.staticValue.dynamicData\n    ) {\n      data.directive = sub(data.staticValue) as any;\n    }\n    return data;\n  });\n}\n","import { getHost } from './component';\n\nexport function createEvent(\n  name: string,\n  customEventInit: Omit<CustomEventInit, 'detail'> = {\n    bubbles: true,\n    composed: true,\n  }\n) {\n  const host = getHost();\n  return (value?: any) =>\n    host.dispatchEvent(\n      new CustomEvent(name, {\n        ...customEventInit,\n        detail: value,\n      })\n    );\n}\n"],"names":["isProxyMap","WeakSet","proxify","obj","onChange","hooks","initialized","onChangeWrapped","Object","keys","forEach","key","has","proxy","Proxy","get","prop","set","value","console","log","add","DOMUpdateType","$state","initialState","listeners","canEmit","l","on","listener","push","index","indexOf","splice","merge","otherState","performMerge","includes","IS_DIRECTIVE","Symbol","createDirective","factory","directive","args","DirectiveType","isLetter","c","toLowerCase","toUpperCase","getTextMarker","id","getAttributeMarker","IS_HTML_RESULT","isDirective","thing","PriorityLevel","resultCache","WeakMap","scheduledJobs","schedulerRunning","processScheduledJobs","now","Date","length","queue","totalElapsed","cb","slice","processJobQueue","sort","a","b","requestAnimationFrame","schedule","priority","NORMAL","IMMEDIATE","Promise","resolve","renderedNodesMap","currentFallback","data","defineFallback","fallback","insertAttributeMarker","marker","si","appendedStatic","char","charAt","generatorMap","applyFallback","assign","staticValue","undefined","containerDataCache","render","container","htmlResult","fragment","init","dataCache","template","dynamicData","staticParts","i","type","TEXT","ATTRIBUTE_VALUE","ATTRIBUTE","dx","document","createElement","innerHTML","trim","createTemplate","generators","content","cloneNode","textNode","textMarker","placeholder","querySelector","isTextArea","firstChild","textareas","querySelectorAll","area","innerText","call","parentNode","replaceChild","node","removeAttribute","Array","from","childNodes","processTemplate","states","prevValues","promise","all","map","findIndex","arg","next","result","domUpdates","d","textContent","ADD_NODE","appendChild","newNode","PREPEND_NODE","insertBefore","REPLACE_NODE","INSERT_BEFORE","INSERT_AFTER","nextSibling","REMOVE","removeChild","ADD_CLASS","classList","REMOVE_CLASS","remove","SET_ATTRIBUTE","setAttribute","name","then","COMPONENT_CONTEXT","getContext","window","getHost","context","host","observerMap","addObserver","element","observer","MutationObserver","mutationsList","attributeName","getAttribute","createPropertyProxy","queueRender","accessedProps","defineProperty","text","regeneratorRuntime","this","clss","classes","HTMLElement","oldClasses","oldCls","split","cls","attr","newArgs","startsWith","replace","cbRef","addEventListener","e","input","target","sub","start","createComment","prevChildren","prevParts","prevFrag","frag","createDocumentFragment","child","html","nodeType","getKey","attribute","join","list","htmlResults","root","end","keyToFragmentsMap","Map","results","oldKeyOrder","tryInsert","handleKey","oldIndex","newIndex","keyOrder","nextIndex","Math","max","previous","previousIndex","unshift","j","oldKeyOrderCopy","keyOrderCopy","_keyName","item","customElements","define","accessedAttributes","$attributes","connectedListeners","sideEffects","_this","attachShadow","mode","$s","attributes","properties","generator","canRunSideEffect","sideEffect","canRun","deps","prevDeps","dep","runSideEffects","promises","_this3","cleanUp","LOW","runCleanUps","force","_this5","_this7","renderPromise","nextQueued","shadowRoot","connectedCallback","connected","stopRenderLoop","_this8","observe","disconnectedListeners","filter","disconnectedCallback","_this10","disconnect","customEventInit","bubbles","composed","dispatchEvent","CustomEvent","detail","dynamicParts","dynamicPart","staticPart","currentDynamicData","attributeValueMode","attributeMode","attributeNameFound","nextChar","nextNextChar"],"mappings":"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"}