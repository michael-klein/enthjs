{"version":3,"file":"enthjs.cjs.production.min.js","sources":["../src/reactivity.ts","../src/directive.ts","../src/composables/element.ts","../src/errors.ts","../src/composables/context.ts","../src/html.ts","../src/directives/clss.ts","../src/scheduler.ts","../src/render.ts","../src/directives/sub.ts","../src/composables/sideeffects.ts","../src/composables/attributes.ts","../src/directives/text.ts","../src/directives/prop.ts","../src/directives/input.ts","../src/directives/on.ts","../src/directives/attr.ts","../src/directives/list.ts","../src/composables/properties.ts","../src/component.ts"],"sourcesContent":["const isProxyMap: WeakSet<object> = new WeakSet();\nfunction proxify(obj: any, onChange: () => void): any {\n  let initialized = false;\n  let onChangeWrapped = () => {\n    if (initialized) {\n      onChange();\n    }\n  };\n  const proxy = new Proxy(obj as any, {\n    get: (obj, prop) => {\n      if (\n        obj[prop] &&\n        typeof obj[prop] === 'object' &&\n        !isProxyMap.has(obj[prop]) &&\n        prop !== 'on' &&\n        initialized\n      ) {\n        obj[prop] = proxify(obj[prop], onChange);\n      }\n      return obj[prop];\n    },\n    set: (obj, prop, value) => {\n      if (\n        (obj[prop] !== value || !initialized) &&\n        prop !== '__$p' &&\n        prop !== 'on'\n      ) {\n        if (typeof value === 'object' && !isProxyMap.has(obj[prop])) {\n          value = proxify(value, onChangeWrapped);\n        }\n        obj[prop] = value;\n        onChangeWrapped();\n      } else if (prop === 'on') {\n        obj[prop] = value;\n      }\n      return true;\n    },\n  });\n  Object.keys(obj).forEach(key => {\n    proxy[key] = obj[key];\n  });\n  isProxyMap.add(proxy);\n  initialized = true;\n  return proxy;\n}\nexport type State<S extends {} = {}> = S & {\n  on: (listener: () => void) => () => void;\n};\n\nexport const $state = <S extends {} = {}>(\n  initialState: Partial<S> = {}\n): State<S> => {\n  const proxy = proxify(initialState, () => {\n    listeners.forEach(l => l());\n  });\n  let listeners: (() => void)[] = [];\n  proxy.on = (listener: () => void): (() => void) => {\n    listeners.push(listener);\n    return () => {\n      const index = listeners.indexOf(listener);\n      if (index > 1) {\n        listeners.splice(index, 1);\n      }\n    };\n  };\n  return proxy;\n};\n","export interface DOMUpdate {\n  node: Node;\n  newNode?: Node;\n  type: DOMUpdateType;\n  value?: string;\n  name?: string;\n}\nexport enum DOMUpdateType {\n  TEXT,\n  REPLACE_NODE,\n  ADD_NODE,\n  INSERT_BEFORE,\n  REMOVE,\n  ADD_CLASS,\n  REMOVE_CLASS,\n  SET_ATTRIBUTE,\n}\n\nexport type DirectiveGenerator<Args extends any[] = any[]> = Generator<\n  DOMUpdate[] | Promise<DOMUpdate[]> | void,\n  void,\n  Args\n>;\n\nexport type DirectiveGeneratorFactory<\n  N extends Node = Node,\n  Args extends any[] = any[]\n> = (node: N, ...initialArgs: Args) => DirectiveGenerator<Args>;\nexport interface DirectiveResult<\n  N extends Node = Node,\n  Args extends any[] = any[]\n> {\n  factory: DirectiveGeneratorFactory<N, Args>;\n  args: Args;\n  directive: Directive;\n}\nexport type Directive<N extends Node = Node, Args extends any[] = any[]> = (\n  ...args: Args\n) => DirectiveResult<N, Args>;\nexport const IS_DIRECTIVE = Symbol('directive');\nexport function createDirective<\n  Args extends any[],\n  N extends Node = any,\n  F extends DirectiveGeneratorFactory<N, Args> = DirectiveGeneratorFactory<\n    N,\n    Args\n  >\n>(\n  factory: F\n): F extends (node: N, ...initialArgs: infer A) => DirectiveGenerator<any>\n  ? Directive<N, A>\n  : never {\n  return ((factory: F) => {\n    const directive = function(...args: Args) {\n      return {\n        is: IS_DIRECTIVE,\n        factory,\n        args,\n        directive,\n      };\n    } as any;\n    return directive;\n  })(factory);\n}\n","import { getOnlySetupError } from '../errors';\n\nconst global: { __$c: HTMLElement } = window as any;\n\nexport const setUpContext = (context: HTMLElement, cb: () => void): void => {\n  global.__$c = context;\n  cb();\n  global.__$c = undefined;\n};\n\nexport const getElement = (): HTMLElement => {\n  if (global.__$c) {\n    return global.__$c;\n  } else {\n    throw getOnlySetupError('getElement');\n  }\n};\n","export const getOnlySetupError = (subject: string): string =>\n  `${subject} can only be used during setup!`;\n","import { State, $state } from '../reactivity';\nimport { getElement } from './element';\n\nconst contextMap: WeakMap<Node, { [key: string]: State<any> }> = new WeakMap();\n\nexport interface ContextAPI<Context extends {}> {\n  provide: (value: Context) => State<Context>;\n  get: () => State<Context>;\n}\nexport function createContext<Context extends {}>(\n  name: string,\n  defaulValue: Context\n): ContextAPI<Context> {\n  const $defaultContext = $state<Context>(defaulValue);\n  return {\n    provide: (value: Context) => {\n      contextMap.set(getElement(), {\n        ...(contextMap.get(getElement()) || {}),\n        [name]: $state<Context>(value),\n      });\n      return contextMap.get(getElement())[name];\n    },\n    get: () => {\n      const element = getElement();\n      let parent: Node = element;\n      while (\n        (parent = parent.parentNode || (parent as any).host) &&\n        parent !== document.body\n      ) {\n        const $context = contextMap.has(parent) && contextMap.get(parent)[name];\n        if ($context) {\n          return $context;\n        }\n      }\n      return $defaultContext;\n    },\n  };\n}\n","import { IS_DIRECTIVE, DirectiveResult } from './directive';\n\nconst isLetter = (c: string): boolean => {\n  return c.toLowerCase() != c.toUpperCase();\n};\n\nexport enum DirectiveType {\n  TEXT,\n  ATTRIBUTE,\n  ATTRIBUTE_VALUE,\n}\nexport interface DirectiveData {\n  d: DirectiveResult;\n  t?: DirectiveType;\n  a?: string;\n}\nconst insertAttributeMarker = (\n  marker: string,\n  si: number,\n  appendedStatic: string\n): string => {\n  while (si++) {\n    const char = appendedStatic.charAt(si);\n    if (!char) {\n      break;\n    }\n    if (char === ' ') {\n      return (\n        appendedStatic.slice(0, si) + ' ' + marker + appendedStatic.slice(si)\n      );\n    }\n  }\n  return appendedStatic;\n};\nexport const getTextMarker = (id: number): string => {\n  return `tm-${id}`;\n};\nexport const getAttributeMarker = (id: number): string => {\n  return `data-am-${id}`;\n};\nexport interface HTMLResult {\n  template: HTMLTemplateElement;\n  directives: DirectiveData[];\n  key?: string;\n}\nexport type HTML = typeof html;\nfunction isDirective(thing: any): boolean {\n  return thing.is && thing.is === IS_DIRECTIVE;\n}\nlet resultCache: WeakMap<TemplateStringsArray, HTMLResult> = new WeakMap();\nexport const html = (\n  staticParts: TemplateStringsArray,\n  ...dynamicParts: any[]\n): HTMLResult => {\n  let result: HTMLResult = resultCache.get(staticParts);\n  if (!result) {\n    let appendedStatic: string = '';\n    const directives: DirectiveData[] = [];\n    for (let i = 0; i < dynamicParts.length; i++) {\n      const dynamicPart = dynamicParts[i];\n      const staticPart = staticParts[i];\n      appendedStatic += staticPart;\n      if (!isDirective(dynamicPart)) {\n        appendedStatic += dynamicPart;\n        continue;\n      }\n      let id =\n        directives.push({\n          d: dynamicPart,\n        }) - 1;\n      let si = appendedStatic.length + 1;\n      let attributeValueMode = false;\n      let attributeMode = false;\n      let attributeNameFound = false;\n      let attributeName = '';\n      while (si--) {\n        const char = appendedStatic.charAt(si);\n        const nextChar = appendedStatic.charAt(si - 1);\n        const nextNextChar = appendedStatic.charAt(si - 2);\n        if (char === '>' || si === 0) {\n          let marker = getTextMarker(id);\n          appendedStatic += `<${marker}>&zwnj;</${marker}>`;\n          directives[id].t = DirectiveType.TEXT;\n          break;\n        }\n        if (\n          char === '\"' &&\n          nextChar === '=' &&\n          isLetter(nextNextChar) &&\n          !attributeMode\n        ) {\n          attributeValueMode = true;\n          continue;\n        }\n        if (char === '\"' && nextNextChar !== '=' && !attributeValueMode) {\n          attributeValueMode = false;\n          attributeMode = true;\n          continue;\n        }\n        if (\n          attributeValueMode &&\n          char !== '\"' &&\n          char !== '=' &&\n          !attributeNameFound\n        ) {\n          if (char !== ' ') {\n            attributeName = char + attributeName;\n          } else {\n            attributeNameFound = true;\n          }\n        }\n        if (char === '<' && attributeValueMode) {\n          appendedStatic = insertAttributeMarker(\n            getAttributeMarker(id),\n            si,\n            appendedStatic\n          );\n          directives[id].t = DirectiveType.ATTRIBUTE_VALUE;\n          directives[id].a = attributeName;\n          if (appendedStatic[appendedStatic.length - 1] === ' ') {\n            appendedStatic = appendedStatic.slice(0, appendedStatic.length - 1);\n          }\n          break;\n        }\n        if (char === '<' && !attributeValueMode) {\n          appendedStatic = insertAttributeMarker(\n            getAttributeMarker(id),\n            si,\n            appendedStatic\n          );\n          directives[id].t = DirectiveType.ATTRIBUTE;\n          break;\n        }\n      }\n    }\n    appendedStatic += staticParts[staticParts.length - 1];\n    const template = document.createElement('template');\n    template.innerHTML = appendedStatic.trim();\n    result = {\n      template,\n      directives,\n    };\n  } else {\n    let directiveIndex: number = 0;\n    result = {\n      ...result,\n      directives: result.directives.map(directive => {\n        const { a, t } = directive;\n        return {\n          a,\n          t,\n          d: undefined,\n        };\n      }),\n    };\n    dynamicParts.forEach((value: any) => {\n      if (isDirective(value)) {\n        result.directives[directiveIndex].d = value;\n        directiveIndex++;\n      }\n    });\n  }\n  resultCache.set(staticParts, result);\n  return result;\n};\n","import { createDirective, DOMUpdate, DOMUpdateType } from '../directive';\n\nexport const clss = createDirective(function*(node: Node, classes: string) {\n  if (node instanceof HTMLElement) {\n    let oldClasses: string[] = [];\n    for (;;) {\n      const result: DOMUpdate[] = [];\n      oldClasses.forEach(oldCls => {\n        if (!!oldCls) {\n          result.push({\n            type: DOMUpdateType.REMOVE_CLASS,\n            node,\n            value: oldCls,\n          });\n        }\n      });\n      oldClasses = classes.trim().split(' ');\n      oldClasses.forEach(cls => {\n        if (!!cls) {\n          result.push({\n            type: DOMUpdateType.ADD_CLASS,\n            node,\n            value: cls,\n          });\n        }\n      });\n      classes = (yield result)[0];\n    }\n  }\n});\n","export enum PriorityLevel {\n  IMMEDIATE = 0, //synchronous\n  USER_BLOCKING = 250, //.25s timeout\n  NORMAL = 5000, // 5s timeout\n  LOW = 10000, // 10s timeout\n  IDLE = 99999999, // no timeout (run only when nothing else is scheduled)\n}\ntype ScheduledJob = [() => void, number];\nlet scheduledJobs: ScheduledJob[] = [];\nlet schedulerRunning: boolean = false;\nconst MAX_ELAPSED: number = 17;\nconst processJobQueue = (\n  queue: ScheduledJob[],\n  now: number\n): ScheduledJob[] => {\n  let index = 0;\n  for (let length = queue.length; index < length; index++) {\n    const totalElapsed: number = Date.now() - now;\n    const [cb, latestEndTime] = queue[index];\n    if (now >= latestEndTime || totalElapsed < MAX_ELAPSED) {\n      cb();\n    } else {\n      break;\n    }\n  }\n  return queue.slice(index);\n};\nconst processScheduledJobs = () => {\n  const now: number = Date.now();\n  scheduledJobs = processJobQueue(\n    scheduledJobs.sort((a, b) => (a[1] < b[1] ? -1 : 1)),\n    now\n  );\n  if (scheduledJobs.length > 0) {\n    requestAnimationFrame(processScheduledJobs);\n  } else {\n    schedulerRunning = false;\n  }\n};\nexport const schedule = (\n  cb: () => void,\n  priority: PriorityLevel = PriorityLevel.NORMAL\n): Promise<void> => {\n  if (priority === PriorityLevel.IMMEDIATE) {\n    cb();\n  } else {\n    return new Promise(resolve => {\n      scheduledJobs.push([\n        () => {\n          cb();\n          resolve();\n        },\n        Date.now() + priority,\n      ]);\n      if (!schedulerRunning) {\n        requestAnimationFrame(processScheduledJobs);\n        schedulerRunning = true;\n      }\n    });\n  }\n  return Promise.resolve();\n};\nexport type Schedule = typeof schedule;\n","import {\n  HTMLResult,\n  DirectiveType,\n  getTextMarker,\n  getAttributeMarker,\n} from './html';\nimport { DirectiveGenerator, DOMUpdate, DOMUpdateType } from './directive';\nimport { schedule } from './scheduler';\n\nconst renderedNodesMap: WeakMap<HTMLElement, Node[]> = new WeakMap();\nexport const clear = (container: HTMLElement) => {\n  if (renderedNodesMap.has(container)) {\n    renderedNodesMap\n      .get(container)\n      .forEach(node => container.removeChild(node));\n    renderedNodesMap.delete(container);\n  }\n};\nconst generatorMap: WeakMap<HTMLElement, DirectiveGenerator[]> = new WeakMap();\nexport const render = (\n  container: HTMLElement,\n  htmlResult: HTMLResult\n): void => {\n  let fragment: DocumentFragment;\n  if (!renderedNodesMap.has(container)) {\n    const generators: DirectiveGenerator[] = [];\n    generatorMap.set(container, generators);\n    fragment = htmlResult.template.content.cloneNode(true) as DocumentFragment;\n    htmlResult.directives.forEach((directiveData, id) => {\n      switch (directiveData.t) {\n        case DirectiveType.TEXT:\n          const placeholder = fragment.querySelector(getTextMarker(id));\n          const textNode = placeholder.firstChild;\n          generators[id] = directiveData.d.factory(\n            textNode,\n            ...directiveData.d.args\n          );\n          placeholder.parentNode.replaceChild(textNode, placeholder);\n          break;\n        case DirectiveType.ATTRIBUTE:\n        case DirectiveType.ATTRIBUTE_VALUE:\n          const marker = getAttributeMarker(id);\n          const node = fragment.querySelector(`[${marker}]`);\n          generators[id] = directiveData.d.factory(\n            node,\n            ...directiveData.d.args\n          );\n          node.removeAttribute(marker);\n      }\n    });\n    renderedNodesMap.set(container, Array.from(fragment.childNodes));\n  }\n\n  const generators: DirectiveGenerator[] = generatorMap.get(container);\n  htmlResult.directives.forEach(async (directiveData, id) => {\n    const result = generators[id].next(directiveData.d.args);\n    if (result.value) {\n      const domUpdate: DOMUpdate[] = await result.value;\n      schedule(() => {\n        domUpdate.forEach(d => {\n          switch (d.type) {\n            case DOMUpdateType.TEXT:\n              d.node.textContent = d.value;\n              break;\n            case DOMUpdateType.ADD_NODE:\n              d.node.appendChild(d.newNode);\n              break;\n            case DOMUpdateType.REPLACE_NODE:\n              d.node.parentNode.replaceChild(d.newNode, d.node);\n              break;\n            case DOMUpdateType.INSERT_BEFORE:\n              d.node.parentNode.insertBefore(d.newNode, d.node);\n              break;\n            case DOMUpdateType.REMOVE:\n              d.node.parentNode.removeChild(d.node);\n              break;\n            case DOMUpdateType.ADD_CLASS:\n              (d.node as HTMLElement).classList.add(d.value);\n              break;\n            case DOMUpdateType.REMOVE_CLASS:\n              (d.node as HTMLElement).classList.remove(d.value);\n              break;\n            case DOMUpdateType.SET_ATTRIBUTE:\n              (d.node as HTMLElement).setAttribute(d.name, d.value);\n              break;\n          }\n        });\n      });\n    }\n  });\n  if (fragment) {\n    container.appendChild(fragment);\n  }\n};\n","import { createDirective, DOMUpdateType, DOMUpdate } from '../directive';\nimport { HTMLResult } from '../html';\nimport { render } from '../render';\n\nexport const sub = createDirective(function*(\n  node: Text,\n  htmlResult: HTMLResult\n) {\n  if (node.nodeType === 3) {\n    const start = document.createComment('');\n    let result: DOMUpdate[] = [\n      {\n        type: DOMUpdateType.REPLACE_NODE,\n        node,\n        newNode: start as any,\n      },\n    ];\n    let prevTemplate: HTMLTemplateElement;\n    let prevFrag: DocumentFragment;\n    let prevChildren: Node[] = [];\n    for (;;) {\n      if (prevTemplate === htmlResult.template) {\n        render(prevFrag as any, htmlResult);\n      } else {\n        const frag = document.createDocumentFragment();\n        render(frag as any, htmlResult);\n        prevChildren.forEach(child => {\n          result.push({\n            type: DOMUpdateType.REMOVE,\n            node: child,\n          });\n        });\n        prevChildren = [];\n        frag.childNodes.forEach(child => {\n          prevChildren.push(child);\n          result.push({\n            type: DOMUpdateType.INSERT_BEFORE,\n            node: start,\n            newNode: child,\n          });\n        });\n        prevTemplate = htmlResult.template;\n        prevFrag = frag;\n      }\n      htmlResult = (yield result)[0];\n      result = [];\n    }\n  }\n});\n","import { getElement } from './element';\nimport { schedule, PriorityLevel } from '../scheduler';\n\nexport type CleanUp = () => void;\nexport type SideEffect = () => void | CleanUp;\ninterface SideEffectsMapItem {\n  e: SideEffect;\n  d?: () => any[];\n  p?: any[];\n  c?: CleanUp;\n}\nconst sideEffectsMap: WeakMap<\n  HTMLElement,\n  SideEffectsMapItem[]\n> = new WeakMap();\n\nexport const sideEffect = (effect: () => void, dependencies?: () => any[]) => {\n  const element = getElement();\n  sideEffectsMap.set(\n    element,\n    (sideEffectsMap.get(element) || []).concat({\n      e: effect,\n      d: dependencies,\n    })\n  );\n};\nconst shouldEffectRun = (effectMapItem: SideEffectsMapItem): boolean => {\n  const { d, p } = effectMapItem;\n  let shouldRun: boolean = true;\n  if (d) {\n    const deps = d();\n    if (\n      p &&\n      (deps === p ||\n        (deps.length === p.length &&\n          deps.findIndex((dep, index) => p[index] !== dep))) === -1\n    ) {\n      shouldRun = false;\n    }\n  }\n  return shouldRun;\n};\nexport const runSideEffects = (element: HTMLElement): Promise<void[]> => {\n  const sideEffects = sideEffectsMap.get(element) || [];\n  if (sideEffects.length > 0) {\n    return Promise.all(\n      sideEffects\n        .map(effectMapItem => {\n          const { c } = effectMapItem;\n          if (c && shouldEffectRun(effectMapItem)) {\n            return schedule(() => {\n              c();\n              effectMapItem.c = undefined;\n            }, PriorityLevel.USER_BLOCKING);\n          }\n          return undefined;\n        })\n        .filter(p => p)\n    ).then(() =>\n      Promise.all(\n        sideEffects\n          .map(effectMapItem => {\n            const { e, d } = effectMapItem;\n            let shouldRun: boolean = shouldEffectRun(effectMapItem);\n            if (d) {\n              effectMapItem.p = d();\n            }\n            if (shouldRun) {\n              return schedule(() => {\n                const cleanUp = e();\n                if (cleanUp) {\n                  effectMapItem.c = cleanUp;\n                }\n              }, PriorityLevel.USER_BLOCKING);\n            }\n            return undefined;\n          })\n          .filter(p => p)\n      )\n    );\n  } else {\n    return Promise.resolve([]);\n  }\n};\n","import { $state } from '../reactivity';\nimport { getElement } from './element';\nimport { sideEffect } from './sideeffects';\n\nconst attributeCallbackMap: WeakMap<\n  HTMLElement,\n  { [key: string]: (() => void)[] }\n> = new Map();\nconst observerMap: WeakMap<HTMLElement, MutationObserver> = new WeakMap();\n\nconst addObserver = (element: HTMLElement): void => {\n  if (!observerMap.has(element)) {\n    const observer = new MutationObserver((mutationsList: MutationRecord[]) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === 'attributes') {\n          const callbacks =\n            (attributeCallbackMap.get(element) || {})[mutation.attributeName] ||\n            [];\n          callbacks.forEach(cb => cb());\n        }\n      }\n    });\n    observerMap.set(element, observer);\n  }\n};\n\nconst startObserving = (element: HTMLElement) => {\n  if (observerMap.has(element)) {\n    observerMap.get(element).observe(element, { attributes: true });\n  }\n};\n\nconst stopObserving = (element: HTMLElement) => {\n  if (observerMap.has(element)) {\n    observerMap.get(element).disconnect();\n  }\n};\n\nconst observeAttribute = (\n  element: HTMLElement,\n  name: string,\n  cb: () => void\n): void => {\n  if (!attributeCallbackMap.has(element)) {\n    attributeCallbackMap.set(element, {});\n  }\n  if (!attributeCallbackMap.get(element)[name]) {\n    attributeCallbackMap.get(element)[name] = [];\n  }\n  attributeCallbackMap.get(element)[name].push(cb);\n};\n\nexport const $attr = (\n  name: string,\n  initialValue: string = ''\n): { value: string } => {\n  const element = getElement();\n  addObserver(element);\n  observeAttribute(element, name, () => {\n    const value = element.getAttribute(name);\n    if (state.value !== value) {\n      state.value = element.getAttribute(name);\n    }\n  });\n\n  if (element.hasAttribute(name)) {\n    initialValue = element.getAttribute(name);\n  }\n\n  element.setAttribute(name, initialValue);\n\n  const state = $state({ value: element.getAttribute(name) });\n\n  sideEffect(\n    () => {\n      stopObserving(element);\n      element.setAttribute(name, state.value);\n      startObserving(element);\n    },\n    () => [state.value]\n  );\n\n  return state;\n};\n","import { createDirective, DOMUpdateType } from '../directive';\n\nexport const text = createDirective(function*(node: Text, value: string) {\n  for (;;) {\n    const result = yield [\n      {\n        node,\n        value,\n        type: DOMUpdateType.TEXT,\n      },\n    ];\n    value = result[0];\n  }\n});\n","import { createDirective } from '../directive';\n\nexport const prop = createDirective(function*(\n  node: Node,\n  name: string,\n  value: any\n) {\n  if (node instanceof HTMLElement) {\n    for (;;) {\n      (node as any)[name] = value;\n      const newArgs = yield;\n      name = newArgs[0];\n      value = newArgs[1];\n    }\n  }\n});\n","import { createDirective } from '../directive';\nimport { PriorityLevel, schedule } from '../scheduler';\n\nexport const input = createDirective(function*(\n  node: HTMLElement,\n  cb: (value: string) => void\n) {\n  const cbRef = {\n    cb,\n  };\n  node.addEventListener('input', e => {\n    const value: string = (e.target as HTMLInputElement).value;\n    schedule(() => cbRef.cb(value), PriorityLevel.NORMAL);\n  });\n  for (;;) {\n    cbRef.cb = (yield)[0];\n  }\n});\n","import { createDirective } from '../directive';\nimport { PriorityLevel, schedule } from '../scheduler';\n\nexport const on = createDirective(function*(\n  node: HTMLElement,\n  name: string,\n  cb: <E extends Event>(e: E) => void\n) {\n  const cbRef = {\n    cb,\n  };\n  node.addEventListener(name, e => {\n    schedule(() => cbRef.cb(e), PriorityLevel.IMMEDIATE);\n  });\n  for (;;) {\n    cbRef.cb = (yield)[1];\n  }\n});\n","import { createDirective, DOMUpdate, DOMUpdateType } from '../directive';\n\nexport const attr = createDirective(function*(\n  node: Node,\n  name: string,\n  value: string\n) {\n  if (node instanceof HTMLElement) {\n    for (;;) {\n      const result: DOMUpdate[] = [\n        {\n          type: DOMUpdateType.SET_ATTRIBUTE,\n          node,\n          value,\n          name,\n        },\n      ];\n      const newArgs = yield result;\n      name = newArgs[0];\n      value = newArgs[1];\n    }\n  }\n});\n","import { createDirective, DOMUpdateType, DOMUpdate } from '../directive';\nimport { HTMLResult, getAttributeMarker } from '../html';\nimport { render } from '../render';\n\nexport function getKey(htmlResult: HTMLResult): string {\n  let id: number = 0;\n  for (const directive of htmlResult.directives) {\n    if ((directive.d.directive as any) === key) {\n      const listNode = htmlResult.template.content.querySelector(\n        `[${getAttributeMarker(id)}]`\n      );\n      if (listNode && !listNode.parentElement) return directive.d.args[0];\n    }\n    id++;\n  }\n  return htmlResult.template.innerHTML;\n}\n\nexport const list = createDirective(function*(\n  node: Text,\n  htmlResults: HTMLResult[]\n) {\n  if (node.nodeType === 3) {\n    const root = document.createDocumentFragment();\n    const start = document.createComment('');\n    root.appendChild(start);\n    const keyToFragmentsMap: Map<\n      string,\n      (DocumentFragment | Node)[]\n    > = new Map();\n    let results: DOMUpdate[] = [\n      {\n        type: DOMUpdateType.REPLACE_NODE,\n        node,\n        newNode: root,\n      },\n    ];\n    let oldKeyOrder: string[] = [];\n    for (;;) {\n      const keyOrder: string[] = htmlResults.map(result => {\n        const key = getKey(result);\n        if (!keyToFragmentsMap.has(key)) {\n          const frag = document.createDocumentFragment();\n          render(frag as any, result);\n          keyToFragmentsMap.set(key, [frag, ...Array.from(frag.childNodes)]);\n        } else {\n          const frag = keyToFragmentsMap.get(key)[0] as DocumentFragment;\n          render(frag as any, result);\n        }\n        return key;\n      });\n      if (oldKeyOrder.join('') !== keyOrder.join('')) {\n        results = results.concat(\n          keyOrder.flatMap(newKey => {\n            const oldIndex = oldKeyOrder.indexOf(newKey);\n            if (oldIndex > -1) {\n              oldKeyOrder.splice(oldIndex, 1);\n            }\n            const [, ...children] = keyToFragmentsMap.get(newKey);\n            return children.map(child => {\n              return {\n                type: DOMUpdateType.INSERT_BEFORE,\n                node: start,\n                newNode: child,\n              } as DOMUpdate;\n            });\n          })\n        );\n        results = results.concat(\n          oldKeyOrder.flatMap(oldKey => {\n            const [, ...children] = keyToFragmentsMap.get(oldKey);\n            keyToFragmentsMap.delete(oldKey);\n            return children.map(child => {\n              return {\n                type: DOMUpdateType.REMOVE,\n                node: child,\n              } as DOMUpdate;\n            });\n          })\n        );\n        console.log(results);\n      }\n      oldKeyOrder = keyOrder;\n      htmlResults = (yield results)[0];\n      results = [];\n    }\n  }\n});\n\nexport const key = createDirective(function*(_node: Text, _keyName: string) {});\n","import { getElement } from './element';\nimport { $state } from '../reactivity';\n\nexport const $prop = <T>(name: string, initialValue: T): { value: T } => {\n  const element = getElement() as any;\n  const state = $state({ value: element[name] || initialValue });\n  Object.defineProperty(element, name, {\n    get: () => state.value,\n    set: (value: any) => {\n      state.value = value;\n    },\n  });\n  return state;\n};\n","import { HTMLResult } from './html';\nimport { render } from './render';\nimport { schedule, PriorityLevel } from './scheduler';\nimport { setUpContext } from './composables/element';\nimport { runSideEffects } from './composables/sideeffects';\nimport { State } from './reactivity';\n\nexport interface ComponentDefinition {\n  render: () => HTMLResult;\n  watch?: State<{}>[];\n}\nexport type Setup = () => ComponentDefinition;\nexport const component = (name: string, setup: Setup) => {\n  customElements.define(\n    name,\n    class extends HTMLElement {\n      private renderQueued: boolean = false;\n      private nextRenderQueued: boolean = false;\n      private render: () => HTMLResult;\n      private watch: State<{}>[] = [];\n      private watchOff: (() => void)[];\n      constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        setUpContext(this, () => {\n          const result = setup();\n          this.render = result.render;\n          this.watch = result.watch;\n        });\n      }\n\n      private wasConnected: boolean = false;\n      public connectedCallback() {\n        if (this.isConnected && !this.wasConnected) {\n          this.wasConnected = true;\n          this.performRender();\n          if (this.watch) {\n            this.watchOff = this.watch.map(s =>\n              s.on(() => {\n                this.performRender();\n              })\n            );\n          }\n        }\n      }\n\n      public disconnectedCallback() {\n        if (this.wasConnected) {\n          this.wasConnected = false;\n          if (this.watchOff) {\n            this.watchOff.forEach(s => s());\n            this.watchOff = undefined;\n          }\n        }\n      }\n\n      private performRender() {\n        if (!this.renderQueued) {\n          this.renderQueued = true;\n          schedule(() => {\n            render(this.shadowRoot as any, this.render());\n          }, PriorityLevel.USER_BLOCKING)\n            .then(async () => await runSideEffects(this))\n            .then(() => {\n              this.renderQueued = false;\n              if (this.nextRenderQueued) {\n                this.nextRenderQueued = false;\n                this.performRender();\n              }\n            });\n        } else {\n          this.nextRenderQueued = true;\n        }\n      }\n    }\n  );\n};\n"],"names":["DOMUpdateType","isProxyMap","WeakSet","$state","initialState","proxy","proxify","obj","onChange","initialized","onChangeWrapped","Proxy","get","prop","has","set","value","Object","keys","forEach","key","add","listeners","l","on","listener","push","index","indexOf","splice","global","window","setUpContext","context","cb","__$c","undefined","getElement","subject","contextMap","WeakMap","IS_DIRECTIVE","Symbol","createDirective","factory","directive","args","is","DirectiveType","clss","regeneratorRuntime","node","classes","HTMLElement","oldClasses","result","oldCls","type","REMOVE_CLASS","trim","split","cls","ADD_CLASS","isLetter","c","toLowerCase","toUpperCase","insertAttributeMarker","marker","si","appendedStatic","char","charAt","slice","getTextMarker","id","getAttributeMarker","isDirective","thing","PriorityLevel","resultCache","scheduledJobs","schedulerRunning","processScheduledJobs","now","Date","queue","length","totalElapsed","processJobQueue","sort","a","b","requestAnimationFrame","schedule","priority","NORMAL","IMMEDIATE","Promise","resolve","renderedNodesMap","generatorMap","render","container","htmlResult","fragment","generators","template","content","cloneNode","directives","directiveData","t","TEXT","placeholder","querySelector","textNode","firstChild","d","parentNode","replaceChild","ATTRIBUTE","ATTRIBUTE_VALUE","removeAttribute","Array","from","childNodes","next","domUpdate","textContent","ADD_NODE","appendChild","newNode","REPLACE_NODE","INSERT_BEFORE","insertBefore","REMOVE","removeChild","classList","remove","SET_ATTRIBUTE","setAttribute","name","sub","nodeType","start","document","createComment","prevChildren","prevTemplate","prevFrag","frag","createDocumentFragment","child","sideEffectsMap","sideEffect","effect","dependencies","element","concat","e","shouldEffectRun","effectMapItem","p","shouldRun","deps","findIndex","dep","attributeCallbackMap","Map","observerMap","text","newArgs","input","cbRef","addEventListener","target","attr","getKey","listNode","parentElement","innerHTML","list","htmlResults","root","keyToFragmentsMap","results","oldKeyOrder","keyOrder","map","join","flatMap","newKey","oldIndex","oldKey","children","console","log","_node","_keyName","initialValue","observer","MutationObserver","mutationsList","mutation","attributeName","addObserver","observeAttribute","getAttribute","state","hasAttribute","disconnect","stopObserving","observe","attributes","startObserving","defineProperty","setup","customElements","define","attachShadow","mode","watch","connectedCallback","this","isConnected","wasConnected","performRender","watchOff","s","_this2","disconnectedCallback","renderQueued","nextRenderQueued","_this3","shadowRoot","USER_BLOCKING","then","sideEffects","all","filter","cleanUp","defaulValue","$defaultContext","provide","parent","host","body","$context","staticParts","dynamicParts","directiveIndex","i","dynamicPart","staticPart","attributeValueMode","attributeMode","attributeNameFound","nextChar","nextNextChar","createElement"],"mappings":"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"}